#N canvas 555 166 425 388 10;
#X declare -path ./abstractions;
#N canvas 619 217 559 505 serial-communication 0;
#X msg 249 91 close;
#X obj 14 185 select 192;
#X obj 81 319 spigot;
#X msg 120 296 0;
#X msg 14 244 1;
#X obj 37 375 spigot;
#X msg 53 244 0;
#X obj 14 219 t b b b;
#X obj 14 22 inlet;
#X text 119 239 after data transfer package received \, close spigot
till package initialiser received;
#X obj 37 397 outlet;
#X obj 249 69 inlet;
#X text 89 181 This is 0xc0 in the Arduino code which denotes the beginning
of the data stream;
#X obj 301 69 r pd;
#X obj 301 91 route dsp;
#X text 374 92 control the DSP LED;
#X obj 14 266 t f f;
#X msg 301 113 print \$1;
#X msg 14 46 devices;
#X obj 26 68 inlet;
#X msg 26 90 open \$1;
#X obj 174 339 spigot;
#X obj 241 382 t l b;
#X obj 241 404 print;
#X obj 213 318 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X text 222 339 debug input;
#X obj 120 271 r close-comport;
#X obj 37 347 repack 31;
#X obj 174 361 route bang;
#X obj 103 90 inlet devicename;
#X obj 14 162 comport 6 115200;
#X connect 0 0 30 0;
#X connect 1 0 7 0;
#X connect 1 1 2 0;
#X connect 2 0 27 0;
#X connect 3 0 2 1;
#X connect 4 0 16 0;
#X connect 5 0 10 0;
#X connect 6 0 5 1;
#X connect 7 0 4 0;
#X connect 7 1 27 0;
#X connect 7 2 6 0;
#X connect 8 0 18 0;
#X connect 11 0 0 0;
#X connect 13 0 14 0;
#X connect 14 0 17 0;
#X connect 16 0 5 1;
#X connect 16 1 2 1;
#X connect 17 0 30 0;
#X connect 18 0 30 0;
#X connect 19 0 20 0;
#X connect 20 0 30 0;
#X connect 21 0 28 0;
#X connect 22 0 23 0;
#X connect 22 1 24 0;
#X connect 24 0 21 1;
#X connect 26 0 3 0;
#X connect 27 0 5 0;
#X connect 27 0 21 0;
#X connect 28 1 22 0;
#X connect 29 0 30 0;
#X connect 30 0 1 0;
#X restore 45 290 pd serial-communication;
#X msg 45 131 bang;
#X msg 203 262 bang;
#N canvas 854 388 279 221 receivedData 1;
#X obj 15 30 inlet;
#N canvas 598 74 608 254 analog 1;
#X obj 29 21 inlet;
#X text 147 9 each subpatch contains the values of the potentiometers
of each module. the amount of values passed to that subpatch is the
number of potentiometers of the module * 2;
#N canvas 199 67 413 535 first-module 1;
#X obj 25 10 inlet;
#X obj 25 104 t f b;
#X obj 25 448 +;
#X obj 97 269 +;
#X obj 133 179 +;
#X obj 169 429 +;
#X obj 205 339 +;
#X obj 241 248 +;
#X obj 241 292 s osc1-fallPow;
#X obj 205 382 s osc1-risePow;
#X obj 169 472 s osc1-brk;
#X obj 133 222 s osc1-switch;
#X obj 25 492 s osc1-freq;
#X obj 97 313 s osc1-pmIndex;
#X obj 61 358 +;
#X obj 43 425 * 128;
#X obj 79 336 * 128;
#X obj 115 246 * 128;
#X obj 151 156 * 128;
#X obj 187 406 * 128;
#X obj 223 316 * 128;
#X obj 259 225 * 128;
#X obj 97 291 / 4096;
#X obj 133 200 / 8191;
#X obj 169 450 / 8191;
#X obj 241 270 / 8191;
#X obj 69 57 outlet;
#X obj 57 127 s close-comport;
#X obj 205 360 / 8191;
#X obj 25 82 unpack f f f f f f f f f f f f f f;
#X obj 25 32 list split 14;
#X obj 25 470 /;
#X obj 61 402 + 1;
#X obj 61 380 debounce 5;
#X connect 0 0 30 0;
#X connect 1 0 2 0;
#X connect 1 1 27 0;
#X connect 2 0 31 0;
#X connect 3 0 22 0;
#X connect 4 0 23 0;
#X connect 5 0 24 0;
#X connect 6 0 28 0;
#X connect 7 0 25 0;
#X connect 14 0 33 0;
#X connect 15 0 2 1;
#X connect 16 0 14 1;
#X connect 17 0 3 1;
#X connect 18 0 4 1;
#X connect 19 0 5 1;
#X connect 20 0 6 1;
#X connect 21 0 7 1;
#X connect 22 0 13 0;
#X connect 23 0 11 0;
#X connect 24 0 10 0;
#X connect 25 0 8 0;
#X connect 28 0 9 0;
#X connect 29 0 1 0;
#X connect 29 1 15 0;
#X connect 29 2 14 0;
#X connect 29 3 16 0;
#X connect 29 4 3 0;
#X connect 29 5 17 0;
#X connect 29 6 4 0;
#X connect 29 7 18 0;
#X connect 29 8 5 0;
#X connect 29 9 19 0;
#X connect 29 10 6 0;
#X connect 29 11 20 0;
#X connect 29 12 7 0;
#X connect 29 13 21 0;
#X connect 30 0 29 0;
#X connect 30 1 26 0;
#X connect 31 0 12 0;
#X connect 32 0 31 1;
#X connect 33 0 32 0;
#X restore 29 44 pd first-module;
#N canvas 212 287 309 278 third-module 0;
#X obj 37 17 inlet;
#X obj 37 89 unpack;
#X obj 37 141 +;
#X obj 76 124 * 128;
#X obj 37 163 / 8191;
#X obj 37 231 s ramp;
#X obj 37 39 list split 2;
#X obj 77 62 outlet;
#X obj 37 185 * 1000;
#X obj 37 207 + 15;
#X connect 0 0 6 0;
#X connect 1 0 2 0;
#X connect 1 1 3 0;
#X connect 2 0 4 0;
#X connect 3 0 2 1;
#X connect 4 0 8 0;
#X connect 6 0 1 0;
#X connect 6 1 7 0;
#X connect 8 0 9 0;
#X connect 9 0 5 0;
#X restore 29 91 pd third-module;
#N canvas 713 95 368 551 second-module 0;
#X obj 25 7 inlet;
#X obj 25 408 +;
#X obj 111 219 +;
#X obj 154 129 +;
#X obj 68 313 +;
#X obj 25 454 s osc2-freq;
#X obj 111 262 s osc2-pmIndex;
#X obj 43 385 * 128;
#X obj 86 291 * 128;
#X obj 129 196 * 128;
#X obj 172 106 * 128;
#X obj 111 240 / 4096;
#X obj 154 172 s osc2-pow;
#X obj 154 150 * 0.02;
#X obj 65 52 outlet;
#X obj 25 82 unpack f f f f f f f f;
#X obj 25 29 list split 8;
#X obj 25 430 /;
#X obj 68 357 + 1;
#X obj 68 335 debounce 5;
#X connect 0 0 16 0;
#X connect 1 0 17 0;
#X connect 2 0 11 0;
#X connect 3 0 13 0;
#X connect 4 0 19 0;
#X connect 7 0 1 1;
#X connect 8 0 4 1;
#X connect 9 0 2 1;
#X connect 10 0 3 1;
#X connect 11 0 6 0;
#X connect 13 0 12 0;
#X connect 15 0 1 0;
#X connect 15 1 7 0;
#X connect 15 2 4 0;
#X connect 15 3 8 0;
#X connect 15 4 2 0;
#X connect 15 5 9 0;
#X connect 15 6 3 0;
#X connect 15 7 10 0;
#X connect 16 0 15 0;
#X connect 16 1 14 0;
#X connect 17 0 5 0;
#X connect 18 0 17 1;
#X connect 19 0 18 0;
#X restore 29 67 pd second-module;
#X obj 29 115 outlet;
#X connect 0 0 2 0;
#X connect 2 0 4 0;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X restore 15 53 pd analog;
#N canvas 133 155 1034 509 comparison-tables 0;
#X msg 595 136 resize \$1;
#X floatatom 116 350 5 0 0 2 index - -, f 5;
#X floatatom 63 350 5 0 0 2 value - -, f 5;
#X obj 432 33 loadbang;
#X obj 557 245 v num_of_modules;
#X floatatom 534 26 5 0 0 2 num_of_modules - -, f 5;
#X msg 182 345 store;
#X msg 186 368 read;
#X obj 618 203 s switch_pins;
#X obj 595 223 s num_of_switches;
#X symbolatom 11 319 16 0 0 2 set_table - -, f 16;
#X msg 185 389 clear;
#X msg 534 97 3;
#X obj 11 338 t s b;
#N canvas 415 387 731 346 create-tables 0;
#X obj 268 114 until;
#X obj 268 157 f;
#X obj 298 158 + 1;
#X obj 291 201 * 20;
#X msg 283 136 0;
#X obj 291 223 + 10;
#X obj 291 245 pack;
#X obj 291 290 s pd-tables;
#X msg 291 268 obj 300 \$1 table previous_states\$2;
#X obj 26 76 sel;
#X obj 268 179 t f f f;
#X obj 26 143 until;
#X obj 26 186 f;
#X obj 56 187 + 1;
#X msg 41 163 0;
#X obj 26 208 pack;
#X msg 26 230 \; previous_states\$1 resize \$2;
#X obj 44 55 - 1;
#X obj 26 121 t f b;
#X obj 26 99 v outlets;
#X obj 127 191 v inlets;
#X msg 268 43 bang;
#X obj 95 59 t b b;
#X obj 95 37 inlet;
#X text 94 19 set size of previous states tables;
#X text 299 43 create previous state tables (if they don't already
exist);
#X obj 268 66 v outlets;
#X obj 268 89 t f b f;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 10 0;
#X connect 2 0 1 1;
#X connect 3 0 5 0;
#X connect 4 0 1 1;
#X connect 5 0 6 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X connect 9 0 19 0;
#X connect 10 0 9 0;
#X connect 10 1 3 0;
#X connect 10 2 6 1;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 12 0 15 0;
#X connect 13 0 12 1;
#X connect 14 0 12 1;
#X connect 15 0 16 0;
#X connect 17 0 9 1;
#X connect 18 0 11 0;
#X connect 18 1 14 0;
#X connect 19 0 18 0;
#X connect 20 0 15 1;
#X connect 21 0 26 0;
#X connect 22 0 19 0;
#X connect 22 1 20 0;
#X connect 23 0 22 0;
#X connect 26 0 27 0;
#X connect 27 0 0 0;
#X connect 27 1 4 0;
#X connect 27 2 17 0;
#X restore 455 412 pd create-tables;
#X obj 534 45 t b f;
#X msg 566 66 set \$1;
#X obj 595 158 t a a a;
#X obj 641 182 s input_pins;
#X msg 548 310 4;
#X obj 548 332 v inlets;
#X obj 510 363 v outlets;
#X text 579 363 number of outlets and inlets of [mtx_*~];
#X obj 432 80 t b b b;
#X obj 455 293 t b b b;
#X text 9 65 switch_pins table should store the pin the first switch
is attached to on each module \, starting from 0;
#X text 9 101 num_of_switches table should store the number of switches
on each module;
#X msg 175 324 manual;
#X msg 169 302 automatic;
#X text 238 302 index;
#X text 224 325 index;
#X text 226 345 values;
#X text 223 368 values;
#X text 228 389 [textfile];
#N canvas 343 66 702 626 set-values-to-tables 0;
#X obj 21 314 tabwrite;
#X obj 121 206 t b b;
#X obj 103 297 f;
#X obj 133 298 + 1;
#X msg 121 275 0;
#X obj 39 234 t f b;
#X obj 103 251 spigot;
#X msg 142 229 1;
#X msg 175 205 0;
#X obj 21 4 inlet which_table;
#X obj 39 110 inlet value;
#X obj 74 135 inlet index;
#X obj 21 53 list prepend set;
#X obj 21 75 list trim;
#X obj 229 379 textfile;
#X msg 337 206 clear;
#X msg 195 299 write ./data/tables.txt;
#X msg 205 277 add \$1;
#X msg 249 351 rewind;
#X msg 269 329 read ./data/tables.txt;
#X obj 21 26 t s b s;
#X obj 261 572 s;
#X msg 289 274 1;
#X obj 241 464 spigot;
#X msg 314 396 0;
#X msg 461 330 symbol write;
#X msg 261 532 \$2 ./data/\$1.txt;
#X obj 261 509 pack s s;
#X obj 229 250 t b b b b;
#X obj 229 206 t b b;
#X obj 283 206 t b b;
#X msg 462 306 symbol read;
#X text 293 366 store table names to a text file to be able to call
them automatically;
#X obj 229 401 t b a;
#X obj 288 555 symbol;
#X obj 261 486 t a a;
#X obj 121 161 inlet features;
#X obj 121 184 route automatic manual store read clear;
#X connect 1 0 4 0;
#X connect 1 1 7 0;
#X connect 2 0 3 0;
#X connect 2 0 0 1;
#X connect 3 0 2 1;
#X connect 4 0 2 1;
#X connect 5 0 0 0;
#X connect 5 1 6 0;
#X connect 6 0 2 0;
#X connect 7 0 6 1;
#X connect 8 0 6 1;
#X connect 9 0 20 0;
#X connect 10 0 5 0;
#X connect 11 0 0 1;
#X connect 12 0 13 0;
#X connect 13 0 0 0;
#X connect 14 0 33 0;
#X connect 14 1 24 0;
#X connect 15 0 14 0;
#X connect 16 0 14 0;
#X connect 17 0 14 0;
#X connect 18 0 14 0;
#X connect 19 0 14 0;
#X connect 20 0 12 0;
#X connect 20 1 16 0;
#X connect 20 2 17 0;
#X connect 22 0 23 1;
#X connect 23 0 14 0;
#X connect 24 0 23 1;
#X connect 25 0 27 1;
#X connect 26 0 21 0;
#X connect 27 0 26 0;
#X connect 28 0 14 0;
#X connect 28 1 18 0;
#X connect 28 2 19 0;
#X connect 28 3 22 0;
#X connect 29 0 28 0;
#X connect 29 1 25 0;
#X connect 30 0 28 0;
#X connect 30 1 31 0;
#X connect 31 0 27 1;
#X connect 33 0 23 0;
#X connect 33 1 35 0;
#X connect 34 0 21 1;
#X connect 35 0 27 0;
#X connect 35 1 34 0;
#X connect 36 0 37 0;
#X connect 37 0 1 0;
#X connect 37 1 8 0;
#X connect 37 2 29 0;
#X connect 37 3 30 0;
#X connect 37 4 15 0;
#X restore 11 369 pd set-values-to-tables;
#X msg 478 319 12;
#X msg 443 55 bang;
#N canvas 463 71 513 492 tables 0;
#X obj 18 32 table switch_pins;
#X obj 18 52 table num_of_switches;
#X obj 18 12 table input_pins;
#X obj 300 10 table previous_states0;
#X obj 300 30 table previous_states1;
#X obj 300 50 table previous_states2;
#X obj 300 70 table previous_states3;
#X obj 300 90 table previous_states4;
#X obj 300 110 table previous_states5;
#X obj 300 130 table previous_states6;
#X obj 300 150 table previous_states7;
#X obj 300 170 table previous_states8;
#X obj 300 190 table previous_states9;
#X obj 300 210 table previous_states10;
#X obj 300 230 table previous_states11;
#X restore 10 273 pd tables;
#N canvas 576 241 311 279 zero-previous_states 0;
#X obj 75 15 inlet;
#X obj 75 37 v outlets;
#X obj 75 81 until;
#X obj 75 124 f;
#X obj 105 125 + 1;
#X msg 93 103 0;
#X obj 75 146 t b f;
#X msg 107 193 symbol previous_states\$1;
#X msg 75 168 const 0;
#X obj 75 210 s;
#X obj 75 59 t f b b;
#X obj 121 81 s matrix;
#X connect 0 0 1 0;
#X connect 1 0 10 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 3 1;
#X connect 5 0 3 1;
#X connect 6 0 8 0;
#X connect 6 1 7 0;
#X connect 7 0 9 1;
#X connect 8 0 9 0;
#X connect 10 0 2 0;
#X connect 10 1 5 0;
#X connect 10 2 11 0;
#X restore 455 458 pd zero-previous_states;
#X msg 455 435 bang;
#X obj 534 119 t f f f;
#X obj 478 341 t f f;
#X text 589 386 goes into [pd compare-value] inside [pd set-connections]
;
#X obj 534 267 s num_modules;
#X text 632 263 goes into [pd num-of-loop-repetitions] inside [pd set-connections]
and in [pd get-switches];
#X obj 478 386 s num_outlets;
#X text 10 26 input_pins table should store the number of input pins
used on each module;
#X text 9 137 previous_states\$1 tables store the states of connections.
\$1 is the outlet number of [mtx_*~] and the table's size is the number
of inlets of [mtx_*~] so you get a unique value for all possible connections.
these tables are used in the [pd set-connections] \, where their values
are compared to incoming values. if they are the same \, set-connection
won't output anything \, if they are different \, [pd set-connections]
will output a matrix message of the form "element \$1 \$2 \$3" and
it will store the new connection to the corresponding previous_states\$1
table \, at the corresponding index;
#X connect 0 0 17 0;
#X connect 1 0 34 2;
#X connect 2 0 34 1;
#X connect 3 0 23 0;
#X connect 5 0 15 0;
#X connect 6 0 34 3;
#X connect 7 0 34 3;
#X connect 10 0 13 0;
#X connect 11 0 34 3;
#X connect 12 0 40 0;
#X connect 13 0 34 0;
#X connect 13 1 28 0;
#X connect 15 0 12 0;
#X connect 15 1 16 0;
#X connect 16 0 12 0;
#X connect 17 0 9 0;
#X connect 17 1 8 0;
#X connect 17 2 18 0;
#X connect 19 0 20 0;
#X connect 23 0 7 0;
#X connect 23 1 24 0;
#X connect 23 2 12 0;
#X connect 24 0 14 0;
#X connect 24 1 35 0;
#X connect 24 2 19 0;
#X connect 27 0 34 3;
#X connect 28 0 34 3;
#X connect 35 0 41 0;
#X connect 36 0 23 0;
#X connect 39 0 38 0;
#X connect 40 0 43 0;
#X connect 40 1 4 0;
#X connect 40 2 0 0;
#X connect 41 0 45 0;
#X connect 41 1 21 0;
#X restore 14 120 pd comparison-tables;
#X obj 15 97 outlet;
#N canvas 677 61 384 269 digital 0;
#X obj 49 57 inlet;
#X obj 49 176 outlet;
#N canvas 181 119 775 537 get-switches 0;
#X obj 21 207 until;
#X obj 53 369 f;
#X obj 53 394 &;
#X obj 53 416 == 0;
#X obj 21 484 outlet;
#X obj 21 11 inlet;
#X obj 21 33 unpack f f f;
#X obj 290 188 tabread switch_pins;
#X obj 313 165 tabread num_of_switches;
#X obj 21 72 +;
#X obj 61 55 * 128;
#X text 61 9 incoming bytes are input byte and input chip #;
#X obj 21 441 pack f f f;
#X msg 21 463 \$3 \$1 \$2;
#X obj 267 114 t f f f;
#X obj 89 302 swap 2;
#X obj 89 324 pow;
#X obj 85 369 * 2;
#X obj 21 182 f;
#X obj 290 212 t f f;
#X obj 21 250 f;
#X obj 51 251 + 1;
#X obj 21 293 t f b;
#X text 76 252 start from # of pin the first switch is attached to
;
#X text 322 135 loop for as many times as the number of switches attached
to the current chip;
#X text 87 463 spit input chip # with switch index and value;
#N canvas 772 123 245 249 switch-changed1 0;
#X obj 125 88 f;
#X obj 65 62 t f f f b;
#X obj 85 105 !=;
#X obj 139 187 spigot;
#X obj 85 127 t f f;
#X obj 65 39 inlet;
#X obj 139 209 outlet;
#X obj 85 209 outlet;
#X connect 0 0 2 1;
#X connect 1 0 3 0;
#X connect 1 1 2 0;
#X connect 1 2 0 1;
#X connect 1 3 0 0;
#X connect 2 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 4 1 3 1;
#X connect 5 0 1 0;
#X restore 144 50 pd switch-changed1;
#N canvas 32 148 568 391 switch-changed2 0;
#X obj 34 66 inlet;
#X obj 34 88 t b f;
#X obj 90 68 > 0;
#X obj 34 128 spigot;
#X obj 149 105 t f f f b;
#X obj 209 130 f;
#X obj 169 147 !=;
#X obj 149 269 spigot;
#X obj 149 291 f;
#X obj 149 313 outlet;
#X obj 169 169 t f f;
#X obj 34 216 spigot;
#X obj 73 195 == 0;
#X text 115 69 if the other value has changed open the [spigot] below
;
#X text 85 212 if this value has changed you don't need to bang it
\, if it hasn't \, you should bang it if the other has changed;
#X obj 90 45 inlet changed;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 4 0;
#X connect 2 0 3 1;
#X connect 3 0 11 0;
#X connect 4 0 7 0;
#X connect 4 1 6 0;
#X connect 4 2 5 1;
#X connect 4 3 5 0;
#X connect 5 0 6 1;
#X connect 6 0 10 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 1 7 1;
#X connect 11 0 8 0;
#X connect 12 0 11 1;
#X connect 15 0 2 0;
#X restore 21 94 pd switch-changed2;
#X obj 39 229 f;
#X obj 71 347 f;
#X obj 21 159 t b b f b;
#X text 115 337 values read from tables need to be stored in a variable
cause they won't be output if they don't change and that will cause
an overflow;
#X obj 267 89 moses 255;
#X obj 327 45 r num_modules;
#X obj 327 67 + 1;
#X text 336 89 exclude non-existent table indices;
#X connect 0 0 20 0;
#X connect 1 0 17 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 12 1;
#X connect 5 0 6 0;
#X connect 6 0 9 0;
#X connect 6 1 10 0;
#X connect 6 2 26 0;
#X connect 7 0 19 0;
#X connect 8 0 18 1;
#X connect 9 0 27 0;
#X connect 10 0 9 1;
#X connect 12 0 13 0;
#X connect 13 0 4 0;
#X connect 14 0 12 2;
#X connect 14 1 7 0;
#X connect 14 2 8 0;
#X connect 15 0 16 0;
#X connect 15 1 16 1;
#X connect 16 0 29 1;
#X connect 17 0 1 1;
#X connect 18 0 0 0;
#X connect 19 0 28 1;
#X connect 19 1 15 0;
#X connect 20 0 21 0;
#X connect 20 0 22 0;
#X connect 21 0 20 1;
#X connect 22 0 12 0;
#X connect 22 1 1 0;
#X connect 26 0 27 1;
#X connect 26 1 32 0;
#X connect 27 0 30 0;
#X connect 28 0 20 1;
#X connect 29 0 1 1;
#X connect 30 0 18 0;
#X connect 30 1 28 0;
#X connect 30 2 2 1;
#X connect 30 3 29 0;
#X connect 32 0 14 0;
#X connect 33 0 34 0;
#X connect 34 0 32 1;
#X restore 183 130 pd get-switches;
#N canvas 475 148 600 231 diffuse-switches 0;
#X obj 26 22 inlet;
#X obj 26 48 route 0 1 2;
#N canvas 562 123 543 239 module1 0;
#X obj 52 22 inlet;
#X obj 52 45 route 1;
#X obj 52 67 change;
#X obj 52 89 s scaleOffset1;
#X text 109 44 [route]'s arguments are the pins where the switches
are attached to on the corresponding module \, starting from 0;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X restore 26 117 pd module1;
#N canvas 522 300 529 241 module2 0;
#X obj 37 63 route 1 2;
#X obj 37 129 change;
#X obj 67 85 change;
#X obj 37 39 inlet;
#X obj 37 151 s scaleOffset2;
#X obj 67 107 s pow_scaleOffset;
#X text 85 32 [route]'s arguments are the pins where the switches are
attached to on the corresponding module \, starting from 0;
#X connect 0 0 1 0;
#X connect 0 1 2 0;
#X connect 1 0 4 0;
#X connect 2 0 5 0;
#X connect 3 0 0 0;
#X restore 50 96 pd module2;
#N canvas 260 203 604 229 module3 0;
#X obj 37 29 inlet;
#X obj 37 117 change;
#X obj 67 74 change;
#X obj 37 52 route 2 3;
#X obj 67 96 s patchUpdate;
#X msg 37 139 dsp \$1;
#X obj 37 161 s pd;
#X text 114 47 [route]'s arguments are the pins where the switches
are attached to on the corresponding module \, starting from 0;
#X connect 0 0 3 0;
#X connect 1 0 5 0;
#X connect 2 0 4 0;
#X connect 3 0 1 0;
#X connect 3 1 2 0;
#X connect 5 0 6 0;
#X restore 75 74 pd module3;
#X text 117 43 [route]'s arguments are the indices of the modules \,
starting from 0;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 1 3 0;
#X connect 1 2 4 0;
#X restore 183 154 pd diffuse-switches;
#X obj 49 79 list split 4;
#N canvas 618 68 524 459 set-connections 0;
#X obj 17 13 inlet;
#X obj 17 186 until;
#X obj 17 232 f;
#X obj 17 316 &;
#X obj 17 338 == 0;
#X msg 17 393 element \$3 \$2 \$1;
#X obj 17 418 outlet;
#X obj 17 88 +;
#X obj 35 65 * 128;
#X msg 35 209 1;
#X obj 49 232 * 2;
#X text 22 282 bitwise AND with 1 \, 2 \, 4 \, 8 \, 16 \, 32... and
check for inequality with zero;
#X obj 17 38 unpack f f f f;
#X text 57 6 incoming bytes refer to input byte \, output pin # and
input chip #;
#X obj 17 162 f;
#X obj 17 139 t b b f b;
#X obj 17 257 t f b;
#N canvas 436 208 526 362 banana-changed2 0;
#X obj 34 66 inlet;
#X obj 34 88 t b f;
#X obj 90 65 > 0;
#X obj 34 128 spigot;
#X obj 149 105 t f f f b;
#X obj 209 130 f;
#X obj 166 147 !=;
#X obj 149 269 spigot;
#X obj 149 291 f;
#X obj 149 313 outlet;
#X obj 166 169 t f f;
#X obj 34 216 spigot;
#X obj 73 194 == 0;
#X text 116 60 if the other value has changed open the [spigot] below
;
#X text 84 212 if this value has changed you don't need to bang it
\, if it hasn't \, you should bang it if the other has changed;
#X obj 90 43 inlet;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 4 0;
#X connect 2 0 3 1;
#X connect 3 0 11 0;
#X connect 4 0 7 0;
#X connect 4 1 6 0;
#X connect 4 2 5 1;
#X connect 4 3 5 0;
#X connect 5 0 6 1;
#X connect 6 0 10 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 1 7 1;
#X connect 11 0 8 0;
#X connect 12 0 11 1;
#X connect 15 0 2 0;
#X restore 17 115 pd banana-changed2;
#X text 61 165 run the loop for as many times as the number of pins
used of current input chip;
#N canvas 37 149 602 518 compare-value 0;
#X obj 52 308 t f f;
#X obj 91 331 !=;
#X obj 52 359 spigot;
#X obj 52 381 t f f;
#X msg 245 144 set previous_states\$1;
#X obj 109 304 tabread;
#X obj 277 398 tabwrite;
#X obj 245 166 t a a;
#X obj 85 189 f;
#X obj 115 189 + 1;
#X msg 103 166 0;
#X obj 85 234 +;
#X text 342 397 store altered state;
#X obj 85 422 + 1;
#X text 146 421 + 1 cause [mtx_*~] starts counting from 1;
#X obj 245 121 t f f;
#X obj 119 422 + 1;
#X obj 85 256 t f f f;
#X text 165 303 compare stored state of connection;
#X obj 305 74 + 1;
#X obj 52 83 inlet value;
#X obj 85 113 inlet bang_until;
#X obj 103 141 inlet bang_once;
#X obj 245 25 inlet which_outlet;
#X obj 52 450 pack f f f;
#X obj 52 472 outlet;
#X obj 386 217 inlet inlet_offset;
#X text 315 95 exclude values of non-existent tables;
#X obj 245 96 moses 255;
#X obj 305 52 r num_outlets;
#X connect 0 0 2 0;
#X connect 0 1 1 0;
#X connect 1 0 2 1;
#X connect 2 0 3 0;
#X connect 3 0 24 0;
#X connect 3 1 6 0;
#X connect 4 0 7 0;
#X connect 5 0 1 1;
#X connect 7 0 5 0;
#X connect 7 1 6 0;
#X connect 8 0 9 0;
#X connect 8 0 11 0;
#X connect 9 0 8 1;
#X connect 10 0 8 1;
#X connect 11 0 17 0;
#X connect 13 0 24 1;
#X connect 15 0 4 0;
#X connect 15 1 16 0;
#X connect 16 0 24 2;
#X connect 17 0 13 0;
#X connect 17 1 5 0;
#X connect 17 2 6 1;
#X connect 19 0 28 1;
#X connect 20 0 0 0;
#X connect 21 0 8 0;
#X connect 22 0 10 0;
#X connect 23 0 28 0;
#X connect 24 0 25 0;
#X connect 26 0 11 1;
#X connect 28 0 15 0;
#X connect 29 0 19 0;
#X restore 17 364 pd compare-value;
#N canvas 15 153 699 553 num-of-loop-repetitions 0;
#X obj 214 317 until;
#X obj 214 361 f;
#X obj 244 361 + 1;
#X msg 232 339 0;
#X obj 214 384 tabread input_pins;
#X obj 214 428 +;
#X obj 244 428 f;
#X msg 232 406 0;
#X obj 214 295 t f b b;
#X obj 168 262 moses 1;
#X obj 77 136 tabread input_pins;
#X obj 45 113 t f f;
#X text 53 207 accumulate used input pins of previous chips to set
correct inlet number offset;
#N canvas 274 316 172 238 banana-changed1 0;
#X obj 105 88 f;
#X obj 45 62 t f f f b;
#X obj 65 105 !=;
#X obj 58 157 spigot;
#X obj 65 127 t f f;
#X obj 45 39 inlet;
#X obj 58 179 outlet;
#X obj 8 179 outlet;
#X connect 0 0 2 1;
#X connect 1 0 3 0;
#X connect 1 1 2 0;
#X connect 1 2 0 1;
#X connect 1 3 0 0;
#X connect 2 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 4 1 3 1;
#X connect 5 0 1 0;
#X restore 45 239 pd banana-changed1;
#X obj 105 66 + 1;
#X obj 45 18 inlet input_chip;
#X obj 77 158 outlet loop_times;
#X obj 168 478 outlet inlet_offset;
#X obj 45 263 outlet changed;
#X text 116 86 exclude non-existent table indices;
#X obj 45 88 moses 255;
#X obj 105 44 r num_modules;
#X text 222 260 a 0 won't make [until] run a loop so send it to [+
] in [pd compare-value] explicitly;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 4 0;
#X connect 2 0 1 1;
#X connect 3 0 1 1;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 5 0 17 0;
#X connect 6 0 5 1;
#X connect 7 0 5 1;
#X connect 8 0 0 0;
#X connect 8 1 3 0;
#X connect 8 2 7 0;
#X connect 9 0 17 0;
#X connect 9 1 8 0;
#X connect 10 0 16 0;
#X connect 11 0 13 0;
#X connect 11 1 10 0;
#X connect 13 0 18 0;
#X connect 13 1 9 0;
#X connect 14 0 20 1;
#X connect 15 0 20 0;
#X connect 20 0 11 0;
#X connect 21 0 14 0;
#X restore 140 93 pd num-of-loop-repetitions;
#X connect 0 0 12 0;
#X connect 1 0 2 0;
#X connect 2 0 10 0;
#X connect 2 0 16 0;
#X connect 3 0 4 0;
#X connect 4 0 19 0;
#X connect 5 0 6 0;
#X connect 7 0 17 0;
#X connect 8 0 7 1;
#X connect 9 0 2 1;
#X connect 10 0 2 1;
#X connect 12 0 7 0;
#X connect 12 1 8 0;
#X connect 12 2 19 3;
#X connect 12 3 20 0;
#X connect 14 0 1 0;
#X connect 15 0 14 0;
#X connect 15 1 9 0;
#X connect 15 2 3 1;
#X connect 15 3 19 2;
#X connect 16 0 3 0;
#X connect 16 1 19 1;
#X connect 17 0 15 0;
#X connect 19 0 5 0;
#X connect 20 0 17 1;
#X connect 20 1 14 1;
#X connect 20 2 19 4;
#X restore 49 154 pd set-connections;
#X connect 0 0 4 0;
#X connect 2 0 3 0;
#X connect 4 0 5 0;
#X connect 4 1 2 0;
#X connect 5 0 1 0;
#X restore 15 75 pd digital;
#X connect 0 0 1 0;
#X connect 1 0 4 0;
#X connect 4 0 3 0;
#X restore 45 312 pd receivedData;
#X text 202 245 close serial port;
#N canvas 357 311 794 421 audio-engine 0;
#N canvas 99 154 603 232 osc1-inputs 0;
#X obj 12 61 inlet~;
#X obj 107 61 inlet~;
#X obj 202 61 inlet~;
#X obj 284 61 inlet~;
#X obj 344 61 inlet~;
#X obj 439 61 inlet~;
#X obj 284 83 s~ brk1;
#X obj 202 83 s~ switch1;
#X obj 107 83 s~ phaseMod1;
#X obj 344 83 s~ risePow1;
#X obj 439 83 s~ fallPow1;
#X obj 12 83 s~ freq_ctl1;
#X connect 0 0 11 0;
#X connect 1 0 8 0;
#X connect 2 0 7 0;
#X connect 3 0 6 0;
#X connect 4 0 9 0;
#X connect 5 0 10 0;
#X restore 31 314 pd osc1-inputs;
#X obj 327 246 adc~;
#N canvas 454 504 303 168 osc2-inputs 0;
#X obj 12 61 inlet~;
#X obj 106 61 inlet~;
#X obj 201 61 inlet~;
#X obj 106 83 s~ phaseMod2;
#X obj 201 83 s~ pow;
#X obj 12 83 s~ freq-ctl2;
#X connect 0 0 5 0;
#X connect 1 0 3 0;
#X connect 2 0 4 0;
#X restore 250 314 pd osc2-inputs;
#X obj 31 109 t a a;
#N canvas 147 128 579 433 varShapeOsc~ 0;
#X obj 32 230 *~;
#X obj 32 273 +~;
#X obj 184 191 pack f 20;
#X obj 184 213 line~;
#X obj 293 190 * -1;
#X obj 293 212 + 1;
#X obj 293 234 pack f 20;
#X obj 293 256 line~;
#X text 91 377 turn subpatch on or off \, according to connection state
;
#X obj 32 375 switch~;
#X obj 32 193 varShapesOsc~;
#X obj 32 295 outlet~;
#N canvas 438 217 653 278 freq 0;
#X obj 51 189 *~;
#X obj 209 151 pack f 20;
#X obj 209 173 line~;
#X obj 32 220 outlet~;
#X obj 32 14 r osc1-freq;
#X obj 32 36 pack f 15;
#X obj 32 58 line~;
#X obj 304 104 r patchUpdate;
#X obj 209 104 r reactivate;
#X obj 209 126 param_on-off 1;
#X text 314 126 [param_on-off] argument is outlet number;
#X obj 32 130 *~;
#X obj 50 108 +~ 1;
#X obj 50 86 *~ -1;
#X text 207 193 if a signal is connected to the frequency inlet \,
that signal will control the frequency of this oscillator;
#X obj 51 165 r~ freq_ctl1;
#X connect 0 0 3 0;
#X connect 1 0 2 0;
#X connect 2 0 0 1;
#X connect 2 0 13 0;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 6 0 11 0;
#X connect 7 0 9 1;
#X connect 8 0 9 0;
#X connect 9 0 1 0;
#X connect 11 0 3 0;
#X connect 12 0 11 1;
#X connect 13 0 12 0;
#X connect 15 0 0 0;
#X restore 32 27 pd freq;
#N canvas 287 172 507 314 phase 0;
#X obj 141 47 pack f 20;
#X obj 141 69 line~;
#X obj 47 85 *~;
#X obj 47 63 r~ phaseMod1;
#X obj 47 199 *~;
#X obj 101 161 pack f 20;
#X obj 101 183 line~;
#X obj 47 221 outlet~;
#X obj 141 25 r osc1-pmIndex;
#X obj 196 118 r patchUpdate;
#X obj 101 118 r reactivate;
#X text 204 139 [param_on-off] argument is outlet number;
#X obj 101 140 param_on-off 2;
#X connect 0 0 1 0;
#X connect 1 0 2 1;
#X connect 2 0 4 0;
#X connect 3 0 2 0;
#X connect 4 0 7 0;
#X connect 5 0 6 0;
#X connect 6 0 4 1;
#X connect 8 0 0 0;
#X connect 9 0 12 1;
#X connect 10 0 12 0;
#X connect 12 0 5 0;
#X restore 46 50 pd phase;
#N canvas 184 166 651 325 switch 0;
#X obj 27 71 pack f 20;
#X obj 27 93 line~;
#X obj 27 49 r osc1-switch;
#X obj 124 129 r~ switch1;
#X obj 27 262 outlet~;
#X obj 27 238 clip~ 0 1;
#X obj 105 153 *~;
#X obj 222 137 pack f 20;
#X obj 222 159 line~;
#X obj 45 139 *~ -1;
#X obj 45 161 +~ 1;
#X obj 27 186 *~;
#X obj 105 175 *~;
#X obj 242 83 loadbang;
#X msg 242 105 0;
#X text 267 106 start off with no connection;
#X obj 317 30 r patchUpdate;
#X obj 222 30 r reactivate;
#X text 325 52 [param_on-off] argument is outlet number;
#X obj 222 52 param_on-off 3;
#X text 134 183 if a signal is connected to this control input \, the
respective knob becomes the index of the signal;
#X connect 0 0 1 0;
#X connect 1 0 11 0;
#X connect 1 0 6 0;
#X connect 2 0 0 0;
#X connect 3 0 6 1;
#X connect 5 0 4 0;
#X connect 6 0 12 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 8 0 12 1;
#X connect 9 0 10 0;
#X connect 10 0 11 1;
#X connect 11 0 5 0;
#X connect 12 0 5 0;
#X connect 13 0 14 0;
#X connect 14 0 7 0;
#X connect 16 0 19 1;
#X connect 17 0 19 0;
#X connect 19 0 7 0;
#X restore 61 76 pd switch;
#N canvas 64 191 644 348 break 0;
#X obj 34 44 pack f 20;
#X obj 34 66 line~;
#X obj 34 22 r osc1-brk;
#X obj 132 137 r~ brk1;
#X obj 34 270 outlet~;
#X obj 34 248 clip~ 0 1;
#X obj 113 160 *~;
#X obj 230 167 pack f 20;
#X obj 230 189 line~;
#X obj 52 160 *~ -1;
#X obj 52 182 +~ 1;
#X obj 34 207 *~;
#X obj 113 205 *~;
#X obj 250 113 loadbang;
#X msg 250 135 0;
#X text 275 136 start off with no connection;
#X obj 325 67 r patchUpdate;
#X obj 230 67 r reactivate;
#X text 333 90 [param_on-off] argument is outlet number;
#X obj 230 89 param_on-off 4;
#X obj 113 113 *~ 0.5;
#X obj 113 182 +~ 0.5;
#X text 146 213 if a signal is connected to this control input \, the
respective knob becomes the index of the signal with the control signal
centered at 0.5;
#X connect 0 0 1 0;
#X connect 1 0 11 0;
#X connect 1 0 20 0;
#X connect 2 0 0 0;
#X connect 3 0 6 1;
#X connect 5 0 4 0;
#X connect 6 0 21 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 8 0 12 1;
#X connect 9 0 10 0;
#X connect 10 0 11 1;
#X connect 11 0 5 0;
#X connect 12 0 5 0;
#X connect 13 0 14 0;
#X connect 14 0 7 0;
#X connect 16 0 19 1;
#X connect 17 0 19 0;
#X connect 19 0 7 0;
#X connect 20 0 6 0;
#X connect 21 0 12 0;
#X restore 77 103 pd break;
#N canvas 222 166 679 336 risePow 0;
#X obj 21 51 pack f 20;
#X obj 21 73 line~;
#X obj 21 29 r osc1-risePow;
#X obj 118 123 r~ risePow1;
#X obj 21 262 outlet~;
#X obj 21 239 clip~ 0 1000;
#X obj 99 147 *~;
#X obj 216 153 pack f 20;
#X obj 216 175 line~;
#X obj 40 140 *~ -1;
#X obj 40 162 +~ 1;
#X obj 21 187 *~;
#X obj 99 191 *~;
#X obj 236 99 loadbang;
#X msg 236 121 0;
#X text 261 122 start off with no connection;
#X obj 311 51 r patchUpdate;
#X obj 216 51 r reactivate;
#X text 320 73 [param_on-off] argument is outlet number;
#X obj 216 73 param_on-off 5;
#X obj 99 169 +~ 0.5;
#X text 131 195 if a signal is connected to this control input \, the
respective knob becomes the index of the signal \, with the control
signal going till 0.5 and no lower;
#X connect 0 0 1 0;
#X connect 1 0 11 0;
#X connect 1 0 6 0;
#X connect 2 0 0 0;
#X connect 3 0 6 1;
#X connect 5 0 4 0;
#X connect 6 0 20 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 8 0 12 1;
#X connect 9 0 10 0;
#X connect 10 0 11 1;
#X connect 11 0 5 0;
#X connect 12 0 5 0;
#X connect 13 0 14 0;
#X connect 14 0 7 0;
#X connect 16 0 19 1;
#X connect 17 0 19 0;
#X connect 19 0 7 0;
#X connect 20 0 12 0;
#X restore 91 132 pd risePow;
#N canvas 386 210 661 310 fallPow 0;
#X obj 25 62 pack f 20;
#X obj 25 84 line~;
#X obj 25 40 r osc1-fallPow;
#X obj 122 114 r~ fallPow1;
#X obj 25 261 outlet~;
#X obj 25 238 clip~ 0 1000;
#X obj 103 137 *~;
#X obj 221 144 pack f 20;
#X obj 221 166 line~;
#X obj 44 133 *~ -1;
#X obj 44 155 +~ 1;
#X obj 25 180 *~;
#X obj 103 182 *~;
#X obj 241 90 loadbang;
#X msg 241 112 0;
#X text 266 113 start off with no connection;
#X obj 316 40 r patchUpdate;
#X obj 221 40 r reactivate;
#X text 327 61 [param_on-off] argument is outlet number;
#X obj 221 62 param_on-off 6;
#X obj 103 159 +~ 0.5;
#X text 133 187 if a signal is connected to this control input \, the
respective knob becomes the index of the signal \, with the control
signal going till 0.5 and no lower;
#X connect 0 0 1 0;
#X connect 1 0 11 0;
#X connect 1 0 6 0;
#X connect 2 0 0 0;
#X connect 3 0 6 1;
#X connect 5 0 4 0;
#X connect 6 0 20 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 8 0 12 1;
#X connect 9 0 10 0;
#X connect 10 0 11 1;
#X connect 11 0 5 0;
#X connect 12 0 5 0;
#X connect 13 0 14 0;
#X connect 14 0 7 0;
#X connect 16 0 19 1;
#X connect 17 0 19 0;
#X connect 19 0 7 0;
#X connect 20 0 12 0;
#X restore 105 162 pd fallPow;
#X text 145 353 [switch_on-off] argument is inlet number;
#X obj 32 330 r reactivate;
#X obj 134 331 r patchUpdate;
#X obj 32 353 switch_on-off 1;
#N canvas 647 147 524 486 scale-offset1 0;
#X obj 51 65 change;
#X obj 51 307 + 1;
#X obj 51 331 swap 1;
#X obj 51 353 /;
#X obj 51 375 t f f;
#X obj 69 256 loadbang;
#X msg 69 278 0;
#X obj 51 419 outlet;
#X obj 83 398 outlet;
#X obj 51 120 swap;
#X obj 51 142 pack;
#X obj 51 164 route 1 0;
#X obj 51 231 f;
#X text 80 218 when the patching update is deactivated \, store value
and output it when it is reactivated;
#X obj 51 43 r scaleOffset1;
#X obj 76 92 r patchUpdate;
#X obj 21 193 r reactivate;
#X text 161 43 number is inlet number;
#X connect 0 0 9 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 3 1;
#X connect 3 0 4 0;
#X connect 4 0 7 0;
#X connect 4 1 8 0;
#X connect 5 0 6 0;
#X connect 6 0 1 0;
#X connect 9 0 10 0;
#X connect 9 1 10 1;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 11 1 12 1;
#X connect 12 0 1 0;
#X connect 14 0 0 0;
#X connect 15 0 9 1;
#X connect 16 0 12 0;
#X restore 184 167 pd scale-offset1;
#X text 183 137 change it accordingly inside the subpatch \, in [r
scaleOffset];
#X text 183 124 the number is inlet number \, for clarity reasons.
;
#X connect 0 0 1 0;
#X connect 1 0 11 0;
#X connect 2 0 3 0;
#X connect 3 0 0 1;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 1 1;
#X connect 10 0 0 0;
#X connect 12 0 10 0;
#X connect 13 0 10 1;
#X connect 14 0 10 2;
#X connect 15 0 10 3;
#X connect 16 0 10 4;
#X connect 17 0 10 5;
#X connect 19 0 21 0;
#X connect 20 0 21 1;
#X connect 21 0 9 0;
#X connect 22 0 2 0;
#X connect 22 1 4 0;
#X restore 112 225 pd varShapeOsc~;
#N canvas 490 61 534 346 powSine~ 0;
#X obj 32 125 *~;
#X obj 32 169 +~;
#X obj 32 191 outlet~;
#X obj 134 86 pack f 20;
#X obj 134 108 line~;
#X obj 243 86 * -1;
#X obj 243 108 + 1;
#X obj 243 130 pack f 20;
#X obj 243 152 line~;
#N canvas 299 267 645 360 freq2 0;
#X obj 51 219 *~;
#X obj 149 181 pack f 20;
#X obj 149 203 line~;
#X obj 32 264 outlet~;
#X obj 32 34 r osc2-freq;
#X obj 32 56 pack f 15;
#X obj 32 78 line~;
#X obj 244 136 r patchUpdate;
#X obj 149 136 r reactivate;
#X text 251 158 [param_on-off] argument is outlet number;
#X obj 149 158 param_on-off 7;
#X obj 32 150 *~;
#X obj 50 107 *~ -1;
#X obj 50 129 +~ 1;
#X text 193 203 if a signal is connected to the frequency inlet \,
that signal will control the frequency of this oscillator;
#X obj 51 195 r~ freq_ctl2;
#X connect 0 0 3 0;
#X connect 1 0 2 0;
#X connect 2 0 0 1;
#X connect 2 0 12 0;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 6 0 11 0;
#X connect 7 0 10 1;
#X connect 8 0 10 0;
#X connect 10 0 1 0;
#X connect 11 0 3 0;
#X connect 12 0 13 0;
#X connect 13 0 11 1;
#X connect 15 0 0 0;
#X restore 32 16 pd freq2;
#N canvas 270 158 563 325 phase2 0;
#X obj 141 47 pack f 20;
#X obj 141 69 line~;
#X obj 47 85 *~;
#X obj 47 200 *~;
#X obj 101 162 pack f 20;
#X obj 101 184 line~;
#X obj 47 222 outlet~;
#X obj 47 63 r~ phaseMod2;
#X obj 141 25 r osc2-pmIndex;
#X obj 196 117 r patchUpdate;
#X obj 101 117 r reactivate;
#X text 203 139 [param_on-off] argument is outlet number;
#X obj 101 139 param_on-off 8;
#X connect 0 0 1 0;
#X connect 1 0 2 1;
#X connect 2 0 3 0;
#X connect 3 0 6 0;
#X connect 4 0 5 0;
#X connect 5 0 3 1;
#X connect 7 0 2 0;
#X connect 8 0 0 0;
#X connect 9 0 12 1;
#X connect 10 0 12 0;
#X connect 12 0 4 0;
#X restore 49 39 pd phase2;
#X obj 32 87 powSine~;
#N canvas 469 144 676 360 pow 0;
#X obj 97 175 *~;
#X obj 254 182 pack f 20;
#X obj 254 204 line~;
#X obj 19 277 outlet~;
#X obj 115 153 r~ pow;
#X obj 19 47 r osc2-pow;
#X obj 19 69 pack f 20;
#X obj 19 91 line~;
#X obj 38 160 *~ -1;
#X obj 38 182 +~ 1;
#X obj 19 207 *~;
#X obj 97 220 *~;
#X obj 274 128 loadbang;
#X msg 274 150 0;
#X text 299 151 start off with no connection;
#X obj 349 74 r patchUpdate;
#X obj 254 74 r reactivate;
#X text 356 96 [param_on-off] argument is outlet number;
#X obj 254 96 param_on-off 9;
#X obj 97 197 +~ 0.5;
#X text 123 226 if a signal is connected to this control input \, the
respective knob becomes the index of the signal \, with the control
signal centered at 0.5;
#X connect 0 0 19 0;
#X connect 1 0 2 0;
#X connect 2 0 8 0;
#X connect 2 0 11 1;
#X connect 4 0 0 1;
#X connect 5 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 10 0;
#X connect 7 0 0 0;
#X connect 8 0 9 0;
#X connect 9 0 10 1;
#X connect 10 0 3 0;
#X connect 11 0 3 0;
#X connect 12 0 13 0;
#X connect 13 0 1 0;
#X connect 15 0 18 1;
#X connect 16 0 18 0;
#X connect 18 0 1 0;
#X connect 19 0 11 0;
#X restore 67 62 pd pow;
#X text 92 264 turn subpatch on or off \, according to connection state
;
#X obj 32 264 switch~;
#X text 142 241 [switch_on-off] argument is inlet number;
#X obj 32 219 r reactivate;
#X obj 134 219 r patchUpdate;
#N canvas 650 149 490 455 scale-offset2 0;
#X obj 51 65 change;
#X obj 51 307 + 1;
#X obj 51 331 swap 1;
#X obj 51 353 /;
#X obj 51 375 t f f;
#X obj 69 256 loadbang;
#X msg 69 278 0;
#X obj 51 419 outlet;
#X obj 83 398 outlet;
#X obj 51 120 swap;
#X obj 51 142 pack;
#X obj 51 164 route 1 0;
#X obj 51 231 f;
#X text 80 218 when the patching update is deactivated \, store value
and output it when it is reactivated;
#X obj 76 92 r patchUpdate;
#X obj 21 193 r reactivate;
#X text 161 43 number is inlet number;
#X obj 51 43 r scaleOffset2;
#X connect 0 0 9 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 3 1;
#X connect 3 0 4 0;
#X connect 4 0 7 0;
#X connect 4 1 8 0;
#X connect 5 0 6 0;
#X connect 6 0 1 0;
#X connect 9 0 10 0;
#X connect 9 1 10 1;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 11 1 12 1;
#X connect 12 0 1 0;
#X connect 14 0 9 1;
#X connect 15 0 12 0;
#X connect 17 0 0 0;
#X restore 134 64 pd scale-offset2;
#X text 133 34 change it accordingly inside the subpatch \, in [r scaleOffset]
;
#X text 133 21 the number is inlet number \, for clarity reasons.;
#X obj 32 242 switch_on-off 2;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 3 0 4 0;
#X connect 4 0 0 1;
#X connect 5 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 8 0 1 1;
#X connect 9 0 11 0;
#X connect 10 0 11 1;
#X connect 11 0 0 0;
#X connect 12 0 11 2;
#X connect 16 0 21 0;
#X connect 17 0 21 1;
#X connect 18 0 3 0;
#X connect 18 1 5 0;
#X connect 21 0 14 0;
#X restore 193 246 pd powSine~;
#X obj 361 224 del;
#X obj 402 207 t f f;
#X obj 402 185 spigot;
#X obj 361 112 t f f;
#X text 329 37 when patching is deactivated \, send potentiometer values
to control ramp time for [mtx_*~];
#X obj 361 135 sel 1;
#X obj 31 83 spigot;
#X obj 329 89 t f f;
#X obj 283 66 t f f;
#X obj 31 60 t a a;
#X obj 329 67 r patchUpdate;
#X obj 402 162 r ramp;
#X msg 361 246 15;
#X text 390 240 when patching is reactivated \, delay a bang with the
potentiometer value to set [mtx_*~] back to 15ms;
#N canvas 267 137 244 223 output 0;
#X obj 48 147 dac~;
#N canvas 0 78 275 364 limit 0;
#X obj 47 66 inlet~;
#X obj 47 295 outlet~;
#X obj 47 271 hip~ 20;
#X obj 66 97 env~;
#X obj 66 122 dbtorms;
#X obj 66 169 line~;
#X obj 66 217 +~ 1;
#X obj 47 242 /~;
#X msg 66 145 \$1 10;
#X obj 66 192 lop~ 40;
#X text 53 25 Taken from chaosmonster;
#X connect 0 0 3 0;
#X connect 0 0 7 0;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 4 0 8 0;
#X connect 5 0 9 0;
#X connect 6 0 7 1;
#X connect 7 0 2 0;
#X connect 8 0 5 0;
#X connect 9 0 6 0;
#X restore 48 65 pd limit;
#X obj 48 37 inlet~;
#X obj 73 87 inlet~;
#N canvas 0 78 275 364 limit 0;
#X obj 47 66 inlet~;
#X obj 47 295 outlet~;
#X obj 47 271 hip~ 20;
#X obj 66 97 env~;
#X obj 66 122 dbtorms;
#X obj 66 169 line~;
#X obj 66 217 +~ 1;
#X obj 47 242 /~;
#X msg 66 145 \$1 10;
#X obj 66 192 lop~ 40;
#X text 53 25 Taken from chaosmonster;
#X connect 0 0 3 0;
#X connect 0 0 7 0;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 4 0 8 0;
#X connect 5 0 9 0;
#X connect 6 0 7 1;
#X connect 7 0 2 0;
#X connect 8 0 5 0;
#X connect 9 0 6 0;
#X restore 73 112 pd limit;
#X connect 1 0 0 0;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 4 0 0 1;
#X restore 360 314 pd output;
#X obj 441 129 == 0;
#X obj 63 161 print;
#X obj 63 138 spigot;
#X obj 102 118 tgl 15 0 empty empty debug 17 7 0 10 -262144 -1 -1 0
1;
#N canvas 0 50 450 278 (subpatch) 0;
#X array array1 512 float 2;
#X coords 0 1 511 -1 200 140 1;
#X restore 557 84 graph;
#X obj 481 298 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X obj 481 318 metro 100;
#X obj 481 340 tabwrite~ array1;
#X obj 31 37 inlet;
#N canvas 211 212 1050 403 whole-matrix-and-data-diffusion 0;
#X obj 13 22 inlet;
#X obj 13 318 outlet;
#X text 77 256 matrix MUST have same dimensions as [mtx_*~];
#X obj 462 61 list split 2;
#X msg 502 131 symbol node\$1;
#X obj 502 86 unpack;
#X obj 502 197 s;
#X text 555 61 get inlet number and connection state;
#X obj 124 318 mtx_print;
#X obj 13 279 t a a;
#X obj 124 296 spigot;
#X obj 163 277 tgl 15 0 empty empty debug 17 7 0 10 -262144 -1 -1 0
1;
#X text 19 222 constantly updated matrix that is output only when the
patching update is being REactivated;
#X obj 502 175 f;
#X obj 502 153 t b s;
#X obj 53 72 inlet;
#X text 94 96 bang matrix when patching update is reactivated;
#X obj 462 230 list split 1;
#X obj 541 109 t f f;
#X obj 502 332 s;
#X obj 502 310 f;
#X obj 502 288 t b s;
#X msg 502 253 symbol param\$1;
#X obj 13 44 t a a;
#X obj 53 95 sel 1;
#X text 555 229 get outlet number;
#X text 553 80 and send connection state to corresponding "module"
to control [switch~];
#X text 546 284 send connection state to corresponding subpatch of
corresponding "module" to turn a control signal on or off;
#X obj 13 257 mtx 12 4;
#X obj 53 117 t b b;
#X obj 85 139 s reactivate;
#X text 94 119 and bang subpatches of nodes to update on-off states
;
#X obj 85 163 r matrix;
#X obj 85 185 mtx_zeros 12 4;
#X text 146 164 zero the matrix in case the Teensy goes crazy;
#X text 612 247 [r param\$1] are in the parameters subpatches of each
node inside [param_on-off];
#X text 600 131 [r node\$1] is in [switch_on-off] in each node;
#X connect 0 0 23 0;
#X connect 3 0 17 0;
#X connect 3 1 5 0;
#X connect 4 0 14 0;
#X connect 5 0 4 0;
#X connect 5 1 18 0;
#X connect 9 0 1 0;
#X connect 9 1 10 0;
#X connect 10 0 8 0;
#X connect 11 0 10 1;
#X connect 13 0 6 0;
#X connect 14 0 13 0;
#X connect 14 1 6 1;
#X connect 15 0 24 0;
#X connect 17 1 22 0;
#X connect 18 0 13 1;
#X connect 18 1 20 1;
#X connect 20 0 19 0;
#X connect 21 0 20 0;
#X connect 21 1 19 1;
#X connect 22 0 21 0;
#X connect 23 0 28 0;
#X connect 23 1 3 0;
#X connect 24 0 29 0;
#X connect 28 0 9 0;
#X connect 29 0 28 0;
#X connect 29 1 30 0;
#X connect 32 0 33 0;
#X connect 33 0 28 0;
#X restore 80 93 pd whole-matrix-and-data-diffusion;
#X obj 31 279 mtx_mul~ 12 4 15 ...........................................
;
#X connect 1 0 31 3;
#X connect 1 1 31 4;
#X connect 3 0 31 0;
#X connect 3 1 23 0;
#X connect 4 0 31 1;
#X connect 5 0 31 2;
#X connect 6 0 18 0;
#X connect 7 0 6 1;
#X connect 7 1 31 5;
#X connect 8 0 7 0;
#X connect 9 0 11 0;
#X connect 9 1 21 0;
#X connect 11 0 6 0;
#X connect 12 0 3 0;
#X connect 13 0 14 0;
#X connect 13 1 9 0;
#X connect 14 0 12 1;
#X connect 14 1 30 1;
#X connect 15 0 12 0;
#X connect 15 1 30 0;
#X connect 16 0 13 0;
#X connect 17 0 8 0;
#X connect 18 0 31 5;
#X connect 21 0 8 1;
#X connect 23 0 22 0;
#X connect 24 0 23 1;
#X connect 26 0 27 0;
#X connect 27 0 28 0;
#X connect 29 0 15 0;
#X connect 30 0 31 0;
#X connect 31 0 0 0;
#X connect 31 1 0 1;
#X connect 31 2 0 2;
#X connect 31 3 0 3;
#X connect 31 4 0 4;
#X connect 31 5 0 5;
#X connect 31 6 2 0;
#X connect 31 7 2 1;
#X connect 31 8 2 2;
#X connect 31 9 20 0;
#X connect 31 10 20 1;
#X connect 31 11 20 1;
#X connect 31 11 20 0;
#X connect 31 11 28 0;
#X restore 45 334 pd audio-engine;
#X text 44 114 check serial devices;
#X floatatom 97 153 5 0 0 0 - - -, f 5;
#X text 95 138 open serial port;
#X obj 44 8 cnv 15 80 30 empty empty empty 20 12 0 14 -228485 -66577
0;
#N canvas 278 55 526 335 readme 0;
#X text 36 10 Things you need to check in order for this patch to work
properly along with its Arduino sketch.;
#X text 36 171 In case the Teensy goes crazy and starts reading connections
that are not there \, there is a "zero-previous_states" subpatch in
the comparison-tables subpatch so you can reset them along with [mtx].
;
#X text 36 50 In the [pd receivedData] subpatch \, make sure the [v
outlets] and [v inlets] variables contain the correct number of outlets
and inlets of [mtx_*~]. Check the [pd tables] subpatch and make sure
the tables contain the data dectribed in [pd receivedData] and that
they have the appropriate size ("previous_states\$1" tables must have
the size of the number of inlets of [mtx_*~] and they must be as many
as the outlets).;
#X restore 51 15 pd readme;
#X text 148 165 open device by name;
#X symbolatom 150 183 14 0 0 0 - - -, f 14;
#X obj 150 202 symbol;
#X msg 150 222 devicename \$1;
#X obj 42 68 declare -path ./abstractions;
#X connect 0 0 3 0;
#X connect 1 0 0 0;
#X connect 2 0 0 3;
#X connect 3 0 5 0;
#X connect 7 0 0 1;
#X connect 12 0 13 0;
#X connect 13 0 14 0;
#X connect 14 0 0 2;
