#N canvas 381 180 499 474 10;
#X declare -lib /usr/lib/pd/extra/iemmatrix -lib /usr/lib/pd/extra/zexy
-path ./generic_abstractions -path ./modules -path ./modules/module_instances
;
#X declare -path ../generic_abstractions;
#X declare -path ../generic_abstractions;
#X declare -path ../generic_abstractions -path ./module_instances;
#X text 82 212 close serial port;
#X text 44 116 check serial devices;
#X floatatom 57 166 5 0 0 0 - - -, f 5;
#X text 55 151 open serial port;
#X obj 44 8 cnv 15 80 30 empty empty empty 20 12 0 14 -228485 -66577
0;
#N canvas 141 61 508 394 readme 0;
#X text 36 10 Things you need to check in order for this patch to work
properly along with its Arduino sketch.;
#X text 36 271 In case the Teensy goes crazy and starts reading connections
that are not there \, there is a "zero-previous_states" subpatch in
the comparison-tables subpatch so you can reset them along with [mtx].
;
#X text 36 172 These two variables are also used in [pd create_matrix]
inside [pd matrix_et_al] \, to create the correct [mtx_*~] object along
with the right [throw~]s and [send~]s. If you change your modules \,
and your inlet and outlet variables \, you'll need to create a new
matrix. Just hit [bang( and it will be created automatically;
#X text 36 50 In the [pd comparison-tables] subpatch \, make sure the
[v outlets] and [v inlets] variables contain the correct number of
outlets and inlets of [mtx_*~]. Check the [pd tables] subpatch and
make sure the tables contain the data dectribed in their parent subpatch
and that they have the appropriate size ("previous_states\$1" tables
must have the size of the number of inlets of [mtx_*~] and they must
be as many as the outlets).;
#X restore 51 15 pd readme;
#X text 68 180 open device by name;
#X symbolatom 70 198 14 0 0 0 - - -, f 14;
#X msg 45 133 devices;
#X msg 83 229 close;
#N canvas 363 154 743 515 receive_teensy_data 0;
#X obj 27 220 select 192;
#X text 102 216 This is 0xc0 in the Arduino code which denotes the
beginning of the data stream;
#X obj 27 80 inlet;
#X obj 27 102 route devices float close symbol;
#X msg 27 170 devices;
#X msg 82 148 open \$1;
#X msg 137 126 close;
#X msg 192 126 devicename \$1;
#X obj 27 197 comport 0 115200;
#X obj 264 329 spigot;
#X obj 126 402 spigot;
#X obj 264 374 repack;
#X obj 303 352 tabread num_of_pots;
#X msg 303 307 1;
#X msg 337 312 0;
#X obj 287 465 s;
#X msg 305 441 symbol module\$1;
#X obj 94 339 t b f;
#X obj 264 420 t b l b;
#X obj 94 312 t f f;
#X obj 126 424 t b b f f;
#X msg 165 352 0;
#X msg 197 364 1;
#X obj 461 331 spigot;
#X obj 528 374 t l b;
#X obj 500 310 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X text 509 331 debug input;
#X obj 461 353 route bang;
#X obj 27 242 t b b b;
#X obj 264 396 spigot;
#X msg 194 259 0;
#X msg 27 264 1;
#X obj 27 286 t f f;
#X obj 165 381 f;
#X text 258 94 anything not matching [route]'s args will be input to
[comport] intact (e.g. a [print \$1d( message);
#X obj 194 281 t f f f;
#X obj 528 396 print list;
#X connect 0 0 28 0;
#X connect 0 1 19 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 3 1 5 0;
#X connect 3 2 6 0;
#X connect 3 3 7 0;
#X connect 3 4 8 0;
#X connect 4 0 8 0;
#X connect 5 0 8 0;
#X connect 6 0 8 0;
#X connect 7 0 8 0;
#X connect 8 0 0 0;
#X connect 9 0 11 0;
#X connect 10 0 20 0;
#X connect 11 0 29 0;
#X connect 11 0 23 0;
#X connect 12 0 11 1;
#X connect 13 0 9 1;
#X connect 14 0 9 1;
#X connect 16 0 15 1;
#X connect 17 0 33 0;
#X connect 17 1 10 0;
#X connect 18 0 22 0;
#X connect 18 1 15 0;
#X connect 18 2 14 0;
#X connect 19 0 17 0;
#X connect 19 1 9 0;
#X connect 20 0 21 0;
#X connect 20 1 13 0;
#X connect 20 2 12 0;
#X connect 20 3 16 0;
#X connect 21 0 33 0;
#X connect 22 0 33 1;
#X connect 23 0 27 0;
#X connect 24 0 36 0;
#X connect 24 1 25 0;
#X connect 25 0 23 1;
#X connect 27 1 24 0;
#X connect 28 0 31 0;
#X connect 28 1 11 0;
#X connect 28 2 30 0;
#X connect 29 0 18 0;
#X connect 30 0 35 0;
#X connect 31 0 32 0;
#X connect 32 0 33 0;
#X connect 32 1 29 1;
#X connect 33 0 10 1;
#X connect 35 0 33 0;
#X connect 35 1 29 1;
#X connect 35 2 9 1;
#X restore 45 289 pd receive_teensy_data;
#N canvas 0 69 1110 541 comparison-tables 0;
#X floatatom 720 354 5 0 0 2 index - -, f 5;
#X floatatom 667 354 5 0 0 2 value - -, f 5;
#X obj 455 33 loadbang;
#X obj 566 141 v num_of_modules;
#X floatatom 534 26 5 0 0 2 num_of_modules - -, f 5;
#X msg 796 377 store;
#X msg 801 400 read;
#X symbolatom 615 323 16 0 0 2 set_table - -, f 16;
#X msg 789 421 clear;
#X msg 534 97 3;
#X obj 615 342 t s b;
#N canvas 366 163 346 196 create-tables 0;
#X obj 195 109 s pd-tables;
#X obj 37 21 inlet;
#N canvas 194 51 437 366 pins_and_inlets_tabs 0;
#X obj 68 83 t f f;
#X obj 68 151 pack;
#X obj 100 105 * 20;
#X obj 100 127 + 10;
#X obj 43 18 inlet;
#X obj 43 326 outlet;
#X obj 149 326 outlet;
#X msg 149 195 obj 20 \$1 table all_inlets_tab;
#X msg 108 235 obj 20 \$1 table num_of_switches;
#X msg 88 255 obj 20 \$1 table switch_pins;
#X msg 68 275 obj 20 \$1 table input_pins;
#X obj 43 61 loop;
#X msg 43 39 5;
#X obj 68 173 route 0 1 2 3 4;
#X msg 129 215 obj 20 \$1 table num_of_pots;
#X connect 0 0 1 0;
#X connect 0 1 2 0;
#X connect 1 0 13 0;
#X connect 2 0 3 0;
#X connect 3 0 1 1;
#X connect 4 0 12 0;
#X connect 7 0 6 0;
#X connect 8 0 6 0;
#X connect 9 0 6 0;
#X connect 10 0 6 0;
#X connect 11 0 5 0;
#X connect 11 1 0 0;
#X connect 12 0 11 0;
#X connect 13 0 10 0;
#X connect 13 1 9 0;
#X connect 13 2 8 0;
#X connect 13 3 14 0;
#X connect 13 4 7 0;
#X connect 14 0 6 0;
#X restore 37 68 pd pins_and_inlets_tabs;
#N canvas 0 51 347 255 states_tabs 0;
#X obj 73 101 * 20;
#X obj 73 123 + 10;
#X obj 73 145 pack;
#X msg 73 168 obj 300 \$1 table previous_states\$2;
#X obj 48 36 v outlets;
#X obj 73 78 t f f;
#X obj 48 14 inlet;
#X obj 48 218 outlet;
#X obj 73 190 outlet;
#X obj 48 58 loop;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 8 0;
#X connect 4 0 9 0;
#X connect 5 0 0 0;
#X connect 5 1 2 1;
#X connect 6 0 4 0;
#X connect 9 0 7 0;
#X connect 9 1 5 0;
#X restore 37 92 pd states_tabs;
#N canvas 238 83 629 316 resize 0;
#X obj 40 126 v outlets;
#X obj 90 149 v inlets;
#X obj 40 21 inlet;
#X obj 288 16 inlet;
#X obj 40 202 outlet;
#X obj 288 38 t b b;
#X obj 320 59 v num_of_modules;
#X obj 40 65 loop;
#X obj 295 259 array size;
#X obj 295 82 swap;
#X msg 422 174 symbol all_inlets_tab;
#X msg 422 197 symbol num_of_switches;
#X msg 423 220 symbol switch_pins;
#X msg 423 242 symbol input_pins;
#X msg 102 171 symbol previous_states\$1;
#X obj 65 171 swap;
#X obj 40 148 loop;
#X msg 40 43 5;
#X obj 352 128 sel 0 1 2 3 4;
#X msg 422 151 symbol num_of_pots;
#X obj 320 105 t f f;
#X obj 320 173 == 4;
#X obj 320 195 * 2;
#X obj 295 222 +;
#X connect 0 0 16 0;
#X connect 1 0 15 1;
#X connect 2 0 17 0;
#X connect 3 0 5 0;
#X connect 5 0 1 0;
#X connect 5 1 6 0;
#X connect 6 0 9 1;
#X connect 7 0 0 0;
#X connect 7 1 9 0;
#X connect 9 0 23 0;
#X connect 9 1 20 0;
#X connect 10 0 8 1;
#X connect 11 0 8 1;
#X connect 12 0 8 1;
#X connect 13 0 8 1;
#X connect 14 0 8 1;
#X connect 15 0 8 0;
#X connect 15 1 14 0;
#X connect 16 0 4 0;
#X connect 16 1 15 0;
#X connect 17 0 7 0;
#X connect 18 0 13 0;
#X connect 18 1 12 0;
#X connect 18 2 11 0;
#X connect 18 3 10 0;
#X connect 18 4 19 0;
#X connect 19 0 8 1;
#X connect 20 0 21 0;
#X connect 20 1 18 0;
#X connect 21 0 22 0;
#X connect 22 0 23 1;
#X connect 23 0 8 0;
#X restore 37 116 pd resize;
#X obj 37 138 outlet;
#X obj 37 43 t b b b;
#X msg 215 60 clear;
#X connect 1 0 6 0;
#X connect 2 0 3 0;
#X connect 2 1 0 0;
#X connect 3 0 4 0;
#X connect 3 1 0 0;
#X connect 4 0 5 0;
#X connect 6 0 2 0;
#X connect 6 1 4 1;
#X connect 6 2 7 0;
#X connect 7 0 0 0;
#X restore 455 292 pd create-tables;
#X obj 534 45 t b f;
#X msg 566 66 set \$1;
#X msg 548 190 4;
#X obj 548 212 v inlets;
#X obj 510 243 v outlets;
#X text 579 243 number of outlets and inlets of [mtx_*~];
#X obj 455 173 t b b b;
#X text 9 65 switch_pins table should store the pin the first switch
is attached to on each module \, starting from 0;
#X text 9 101 num_of_switches table should store the number of switches
on each module;
#X msg 786 356 manual;
#X msg 773 334 automatic;
#X text 842 334 index;
#X text 835 357 index;
#X text 840 377 values;
#X text 838 400 values;
#N canvas 329 217 845 504 set-values-to-tables 0;
#X obj 21 235 tabwrite;
#X obj 251 95 t b b;
#X obj 233 186 f;
#X obj 263 187 + 1;
#X msg 251 164 0;
#X obj 39 123 t f b;
#X obj 233 140 spigot;
#X msg 272 118 1;
#X msg 305 94 0;
#X obj 21 4 inlet which_table;
#X obj 39 100 inlet value;
#X obj 21 53 list prepend set;
#X obj 21 75 list trim;
#X obj 359 268 textfile;
#X msg 467 95 clear;
#X msg 325 188 write ./data/tables.txt;
#X msg 335 166 add \$1;
#X msg 379 240 rewind;
#X msg 399 218 read ./data/tables.txt;
#X obj 391 461 s;
#X msg 419 163 1;
#X obj 371 353 spigot;
#X msg 444 285 0;
#X msg 591 219 symbol write;
#X msg 391 421 \$2 ./data/\$1.txt;
#X obj 391 398 pack s s;
#X obj 359 139 t b b b b;
#X obj 359 95 t b b;
#X obj 413 95 t b b;
#X msg 592 195 symbol read;
#X text 423 255 store table names to a text file to be able to call
them automatically;
#X obj 359 290 t b a;
#X obj 423 444 symbol;
#X obj 391 375 t a a;
#X obj 251 50 inlet features;
#X obj 251 73 route automatic manual store read clear;
#X obj 21 26 t s s b b s;
#X obj 127 179 inlet index;
#N canvas 196 98 450 471 set_values 0;
#X obj 36 157 sel num_of_pots;
#X msg 36 179 2;
#X msg 138 214 1;
#X obj 18 231 *;
#X obj 54 312 v num_of_modules;
#X obj 36 356 * 0.5;
#X obj 36 378 + 0.5;
#X obj 36 334 <;
#X obj 18 400 *;
#X obj 264 176 array size;
#X obj 214 243 moses;
#X obj 246 221 +;
#X obj 18 77 inlet value;
#X obj 36 113 inlet table_name;
#X obj 54 288 inlet bang;
#X obj 36 135 t s s;
#X obj 36 204 t f f;
#X obj 214 106 inlet index;
#X obj 138 181 t b b;
#X msg 246 198 0;
#X obj 18 422 outlet value;
#X obj 246 287 outlet index;
#X text 15 20 this whole thing is here so we can store the num_of_pots
elements without needing to calculate the double number of pots;
#X obj 214 265 t f f;
#X obj 264 152 t b s;
#X connect 0 0 1 0;
#X connect 0 1 18 0;
#X connect 1 0 16 0;
#X connect 2 0 3 1;
#X connect 3 0 8 0;
#X connect 4 0 7 1;
#X connect 5 0 6 0;
#X connect 6 0 8 1;
#X connect 7 0 5 0;
#X connect 8 0 20 0;
#X connect 9 0 11 1;
#X connect 10 0 23 0;
#X connect 11 0 10 1;
#X connect 12 0 3 0;
#X connect 13 0 15 0;
#X connect 14 0 4 0;
#X connect 15 0 0 0;
#X connect 15 1 24 0;
#X connect 16 0 3 1;
#X connect 16 1 11 0;
#X connect 17 0 10 0;
#X connect 18 0 2 0;
#X connect 18 1 19 0;
#X connect 19 0 11 0;
#X connect 23 0 7 0;
#X connect 23 1 21 0;
#X connect 24 0 9 0;
#X connect 24 1 9 1;
#X restore 39 203 pd set_values;
#X connect 1 0 4 0;
#X connect 1 1 7 0;
#X connect 2 0 3 0;
#X connect 2 0 38 3;
#X connect 3 0 2 1;
#X connect 4 0 2 1;
#X connect 5 0 38 0;
#X connect 5 1 6 0;
#X connect 6 0 2 0;
#X connect 7 0 6 1;
#X connect 8 0 6 1;
#X connect 9 0 36 0;
#X connect 10 0 5 0;
#X connect 11 0 12 0;
#X connect 12 0 0 0;
#X connect 13 0 31 0;
#X connect 13 1 22 0;
#X connect 14 0 13 0;
#X connect 15 0 13 0;
#X connect 16 0 13 0;
#X connect 17 0 13 0;
#X connect 18 0 13 0;
#X connect 20 0 21 1;
#X connect 21 0 13 0;
#X connect 22 0 21 1;
#X connect 23 0 25 1;
#X connect 24 0 19 0;
#X connect 25 0 24 0;
#X connect 26 0 13 0;
#X connect 26 1 17 0;
#X connect 26 2 18 0;
#X connect 26 3 20 0;
#X connect 27 0 26 0;
#X connect 27 1 23 0;
#X connect 28 0 26 0;
#X connect 28 1 29 0;
#X connect 29 0 25 1;
#X connect 31 0 21 0;
#X connect 31 1 33 0;
#X connect 32 0 19 1;
#X connect 33 0 25 0;
#X connect 33 1 32 0;
#X connect 34 0 35 0;
#X connect 35 0 1 0;
#X connect 35 1 8 0;
#X connect 35 2 27 0;
#X connect 35 3 28 0;
#X connect 35 4 14 0;
#X connect 36 0 11 0;
#X connect 36 1 38 1;
#X connect 36 2 38 2;
#X connect 36 3 15 0;
#X connect 36 4 16 0;
#X connect 37 0 38 3;
#X connect 38 0 0 0;
#X connect 38 1 0 1;
#X restore 615 373 pd set-values-to-tables;
#X msg 466 55 bang;
#N canvas 244 105 513 492 tables 0;
#X obj 20 10 table input_pins;
#X obj 20 30 table switch_pins;
#X obj 20 50 table num_of_switches;
#X obj 20 70 table num_of_pots;
#X obj 20 90 table all_inlets_tab;
#X obj 300 10 table previous_states0;
#X obj 300 30 table previous_states1;
#X obj 300 50 table previous_states2;
#X obj 300 70 table previous_states3;
#X obj 300 90 table previous_states4;
#X obj 300 110 table previous_states5;
#X obj 300 130 table previous_states6;
#X obj 300 150 table previous_states7;
#X obj 300 170 table previous_states8;
#X obj 300 190 table previous_states9;
#X obj 300 210 table previous_states10;
#X obj 300 230 table previous_states11;
#X obj 300 250 table previous_states12;
#X restore 10 502 pd tables;
#N canvas 652 214 315 319 zero-previous_states 0;
#X obj 25 19 inlet;
#X obj 25 41 v outlets;
#X obj 50 130 t b f;
#X msg 82 177 symbol previous_states\$1;
#X msg 50 152 const 0;
#X obj 50 194 s;
#X obj 57 85 s zero_matrix;
#X obj 25 107 loop;
#X obj 25 63 t f b;
#X msg 57 239 print i;
#X obj 57 261 s to_comport;
#X obj 25 217 t b b;
#X obj 25 282 outlet;
#X connect 0 0 1 0;
#X connect 1 0 8 0;
#X connect 2 0 4 0;
#X connect 2 1 3 0;
#X connect 3 0 5 1;
#X connect 4 0 5 0;
#X connect 7 0 11 0;
#X connect 7 1 2 0;
#X connect 8 0 7 0;
#X connect 8 1 6 0;
#X connect 9 0 10 0;
#X connect 11 0 12 0;
#X connect 11 1 9 0;
#X restore 455 428 pd zero-previous_states;
#X obj 478 221 t f f;
#X text 589 266 goes into [pd compare-value] inside [pd set-connections]
;
#X obj 534 163 s num_modules;
#X text 632 159 goes into [pd num-of-loop-repetitions] inside [pd set-connections]
and in [pd get-switches];
#X obj 478 266 s num_outlets;
#X text 10 26 input_pins table should store the number of input pins
used on each module;
#X text 9 356 previous_states\$1 tables store the states of connections.
\$1 is the outlet number of [mtx_*~] and the table's size is the number
of inlets of [mtx_*~] so you get a unique value for all possible connections.
these tables are used in the [pd set-connections] \, where their values
are compared to incoming values. if they are the same \, set-connection
won't output anything \, if they are different \, [pd set-connections]
will output a matrix message of the form "element \$1 \$2 \$3" and
it will store the new connection to the corresponding previous_states\$1
table \, at the corresponding index;
#X msg 478 199 13;
#X obj 455 80 t b b;
#X obj 534 119 t f f;
#X obj 455 383 t b b;
#X obj 455 405 del 200;
#N canvas 193 195 612 229 init-inlets-table 0;
#X obj 100 34 v num_of_modules;
#X msg 148 99 symbol \$1-get_inlet;
#X obj 125 123 s;
#X obj 125 77 t b f f;
#X obj 13 149 r give_inlet;
#X obj 13 171 tabwrite all_inlets_tab;
#X obj 100 56 loop;
#X text 181 52 store all first inlet of every module (reason is explained
inside each modlues that uses this feature - mostly oscillators);
#X obj 100 12 inlet;
#X connect 0 0 6 0;
#X connect 1 0 2 1;
#X connect 3 0 2 0;
#X connect 3 1 1 0;
#X connect 3 2 5 1;
#X connect 4 0 5 0;
#X connect 6 1 3 0;
#X connect 8 0 0 0;
#X restore 455 451 pd init-inlets-table;
#X text 9 133 num_of_pots table stores the number of potentiometers
on each module. the pre-last element of the table should be 4 and the
last 3 (these are the bytes for the connections and the switches);
#X text 9 199 all_inlets_tab table stores the number of the first inlet
of each module in the matrix. this happens automatically at load time.
the reason for this is that we need to define a name for some [receive]s
in some module abstractions \, in the form [r \$3-incoming_amp_freq]
in the oscillator (and probably filter) modules \, in case a module
connects to an inlet of the oscillator \, not the first one. since
only the first inlet is defined in the abstraction's arguments \, and
[receive] is not so flexible in naming it \, we need to know these
numbers \, to define a proper name for these [receive]s. check oscillator
modules for further info;
#X text 832 421 [textfile] before writing new values;
#X connect 0 0 27 2;
#X connect 1 0 27 1;
#X connect 2 0 39 0;
#X connect 4 0 12 0;
#X connect 5 0 27 3;
#X connect 6 0 27 3;
#X connect 7 0 10 0;
#X connect 8 0 27 3;
#X connect 9 0 40 0;
#X connect 10 0 27 0;
#X connect 10 1 22 0;
#X connect 11 0 41 0;
#X connect 12 0 9 0;
#X connect 12 1 13 0;
#X connect 13 0 9 0;
#X connect 14 0 15 0;
#X connect 18 0 11 0;
#X connect 18 1 38 0;
#X connect 18 2 14 0;
#X connect 21 0 27 3;
#X connect 22 0 27 3;
#X connect 28 0 39 0;
#X connect 30 0 43 0;
#X connect 31 0 35 0;
#X connect 31 1 16 0;
#X connect 38 0 31 0;
#X connect 39 0 18 0;
#X connect 39 1 9 0;
#X connect 40 0 33 0;
#X connect 40 1 3 0;
#X connect 41 0 42 0;
#X connect 41 1 6 0;
#X connect 42 0 30 0;
#X restore 45 311 pd comparison-tables;
#N canvas 285 208 775 537 get-switches 0;
#X obj 21 217 until;
#X obj 53 379 f;
#X obj 53 404 &;
#X obj 53 426 == 0;
#X obj 21 43 unpack f f f;
#X obj 290 198 tabread switch_pins;
#X obj 313 175 tabread num_of_switches;
#X obj 21 82 +;
#X obj 61 65 * 128;
#X text 115 39 incoming bytes are input byte and input chip #;
#X obj 21 451 pack f f f;
#X msg 21 473 \$3 \$1 \$2;
#X obj 267 124 t f f f;
#X obj 89 312 swap 2;
#X obj 89 334 pow;
#X obj 85 379 * 2;
#X obj 21 192 f;
#X obj 290 222 t f f;
#X obj 21 260 f;
#X obj 51 261 + 1;
#X obj 21 303 t f b;
#X text 76 262 start from # of pin the first switch is attached to
;
#X text 322 145 loop for as many times as the number of switches attached
to the current chip;
#X text 87 473 spit input chip # with switch index and value;
#N canvas 760 223 245 249 switch-changed1 0;
#X obj 125 88 f;
#X obj 65 62 t f f f b;
#X obj 85 105 !=;
#X obj 139 187 spigot;
#X obj 85 127 t f f;
#X obj 65 39 inlet;
#X obj 139 209 outlet;
#X obj 85 209 outlet;
#X connect 0 0 2 1;
#X connect 1 0 3 0;
#X connect 1 1 2 0;
#X connect 1 2 0 1;
#X connect 1 3 0 0;
#X connect 2 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 4 1 3 1;
#X connect 5 0 1 0;
#X restore 144 60 pd switch-changed1;
#N canvas 301 109 568 391 switch-changed2 0;
#X obj 34 69 inlet;
#X obj 34 91 t b f;
#X obj 100 111 > 0;
#X obj 34 128 spigot;
#X obj 209 108 t f f f b;
#X obj 269 133 f;
#X obj 229 150 !=;
#X obj 209 269 spigot;
#X obj 209 291 f;
#X obj 209 313 outlet;
#X obj 229 172 t f f;
#X obj 34 216 spigot;
#X obj 229 199 == 0;
#X text 99 68 if the other value has changed open the [spigot] below
;
#X text 80 222 if this value has changed you don't need to bang it
\, if it hasn't \, you should bang it if the other has changed;
#X obj 100 88 inlet changed;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 4 0;
#X connect 2 0 3 1;
#X connect 3 0 11 0;
#X connect 4 0 7 0;
#X connect 4 1 6 0;
#X connect 4 2 5 1;
#X connect 4 3 5 0;
#X connect 5 0 6 1;
#X connect 6 0 10 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 1 7 1;
#X connect 11 0 8 0;
#X connect 12 0 11 1;
#X connect 15 0 2 0;
#X restore 21 104 pd switch-changed2;
#X obj 39 239 f;
#X obj 71 357 f;
#X obj 21 169 t b b f b;
#X text 115 347 values read from tables need to be stored in a variable
cause they won't be output if they don't change and that will cause
an overflow;
#X obj 267 99 moses 255;
#X obj 327 55 r num_modules;
#X obj 327 77 + 1;
#X text 336 99 exclude non-existent table indices;
#X obj 21 494 s switches;
#X obj 21 11 r module4;
#X text 89 8 this name is due to the dynamic naming of [send] in the
teensy_data subpatch (the number is num_of_modules + 1);
#X connect 0 0 18 0;
#X connect 1 0 15 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 10 1;
#X connect 4 0 7 0;
#X connect 4 1 8 0;
#X connect 4 2 24 0;
#X connect 5 0 17 0;
#X connect 6 0 16 1;
#X connect 7 0 25 0;
#X connect 8 0 7 1;
#X connect 10 0 11 0;
#X connect 11 0 34 0;
#X connect 12 0 10 2;
#X connect 12 1 5 0;
#X connect 12 2 6 0;
#X connect 13 0 14 0;
#X connect 13 1 14 1;
#X connect 14 0 27 1;
#X connect 15 0 1 1;
#X connect 16 0 0 0;
#X connect 17 0 26 1;
#X connect 17 1 13 0;
#X connect 18 0 19 0;
#X connect 18 0 20 0;
#X connect 19 0 18 1;
#X connect 20 0 10 0;
#X connect 20 1 1 0;
#X connect 24 0 25 1;
#X connect 24 1 30 0;
#X connect 25 0 28 0;
#X connect 26 0 18 1;
#X connect 27 0 1 1;
#X connect 28 0 16 0;
#X connect 28 1 26 0;
#X connect 28 2 2 1;
#X connect 28 3 27 0;
#X connect 30 0 12 0;
#X connect 31 0 32 0;
#X connect 32 0 30 1;
#X connect 35 0 4 0;
#X restore 45 357 pd get-switches;
#N canvas 576 51 565 463 set-connections 0;
#X obj 17 183 until;
#X obj 17 229 f;
#X obj 17 313 &;
#X obj 17 335 == 0;
#X msg 17 390 element \$3 \$2 \$1;
#X obj 17 85 +;
#X obj 48 68 * 128;
#X msg 35 206 1;
#X obj 49 229 * 2;
#X text 22 279 bitwise AND with 1 \, 2 \, 4 \, 8 \, 16 \, 32... and
check for inequality with zero;
#X obj 17 38 unpack f f f f;
#X text 125 45 incoming bytes refer to input byte \, output pin # and
input chip #;
#X obj 17 159 f;
#X obj 17 136 t b b f b;
#X obj 17 254 t f b;
#N canvas 430 204 526 362 banana-changed2 0;
#X obj 34 66 inlet;
#X obj 34 88 t b f;
#X obj 90 65 > 0;
#X obj 34 128 spigot;
#X obj 149 105 t f f f b;
#X obj 209 130 f;
#X obj 166 147 !=;
#X obj 149 269 spigot;
#X obj 149 291 f;
#X obj 149 313 outlet;
#X obj 166 169 t f f;
#X obj 34 216 spigot;
#X obj 73 194 == 0;
#X text 116 60 if the other value has changed open the [spigot] below
;
#X text 84 212 if this value has changed you don't need to bang it
\, if it hasn't \, you should bang it if the other has changed;
#X obj 90 43 inlet;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 4 0;
#X connect 2 0 3 1;
#X connect 3 0 11 0;
#X connect 4 0 7 0;
#X connect 4 1 6 0;
#X connect 4 2 5 1;
#X connect 4 3 5 0;
#X connect 5 0 6 1;
#X connect 6 0 10 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 1 7 1;
#X connect 11 0 8 0;
#X connect 12 0 11 1;
#X connect 15 0 2 0;
#X restore 17 112 pd banana-changed2;
#X text 61 162 run the loop for as many times as the number of pins
used of current input chip;
#N canvas 11 103 602 518 compare-value 0;
#X obj 52 308 t f f;
#X obj 91 331 !=;
#X obj 52 359 spigot;
#X obj 52 381 t f f;
#X msg 245 144 set previous_states\$1;
#X obj 109 304 tabread;
#X obj 277 398 tabwrite;
#X obj 245 166 t a a;
#X obj 85 189 f;
#X obj 115 189 + 1;
#X msg 103 166 0;
#X obj 85 234 +;
#X text 342 397 store altered state;
#X obj 85 422 + 1;
#X text 146 421 + 1 cause [mtx_*~] starts counting from 1;
#X obj 245 121 t f f;
#X obj 119 422 + 1;
#X obj 85 256 t f f f;
#X text 165 303 compare stored state of connection;
#X obj 305 74 + 1;
#X obj 52 83 inlet value;
#X obj 85 113 inlet bang_until;
#X obj 103 141 inlet bang_once;
#X obj 245 25 inlet which_outlet;
#X obj 52 450 pack f f f;
#X obj 52 472 outlet;
#X obj 386 217 inlet inlet_offset;
#X text 315 95 exclude values of non-existent tables;
#X obj 245 96 moses 255;
#X obj 305 52 r num_outlets;
#X connect 0 0 2 0;
#X connect 0 1 1 0;
#X connect 1 0 2 1;
#X connect 2 0 3 0;
#X connect 3 0 24 0;
#X connect 3 1 6 0;
#X connect 4 0 7 0;
#X connect 5 0 1 1;
#X connect 7 0 5 0;
#X connect 7 1 6 0;
#X connect 8 0 9 0;
#X connect 8 0 11 0;
#X connect 9 0 8 1;
#X connect 10 0 8 1;
#X connect 11 0 17 0;
#X connect 13 0 24 1;
#X connect 15 0 4 0;
#X connect 15 1 16 0;
#X connect 16 0 24 2;
#X connect 17 0 13 0;
#X connect 17 1 5 0;
#X connect 17 2 6 1;
#X connect 19 0 28 1;
#X connect 20 0 0 0;
#X connect 21 0 8 0;
#X connect 22 0 10 0;
#X connect 23 0 28 0;
#X connect 24 0 25 0;
#X connect 26 0 11 1;
#X connect 28 0 15 0;
#X connect 29 0 19 0;
#X restore 17 361 pd compare-value;
#N canvas 225 158 699 553 num-of-loop-repetitions 0;
#X obj 214 317 until;
#X obj 214 361 f;
#X obj 244 361 + 1;
#X msg 232 339 0;
#X obj 214 384 tabread input_pins;
#X obj 214 428 +;
#X obj 244 428 f;
#X msg 232 406 0;
#X obj 214 295 t f b b;
#X obj 168 262 moses 1;
#X obj 77 136 tabread input_pins;
#X obj 45 113 t f f;
#X text 53 207 accumulate used input pins of previous chips to set
correct inlet number offset;
#N canvas 265 391 172 238 banana-changed1 0;
#X obj 105 88 f;
#X obj 45 62 t f f f b;
#X obj 65 105 !=;
#X obj 58 157 spigot;
#X obj 65 127 t f f;
#X obj 45 39 inlet;
#X obj 58 179 outlet;
#X obj 8 179 outlet;
#X connect 0 0 2 1;
#X connect 1 0 3 0;
#X connect 1 1 2 0;
#X connect 1 2 0 1;
#X connect 1 3 0 0;
#X connect 2 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 4 1 3 1;
#X connect 5 0 1 0;
#X restore 45 239 pd banana-changed1;
#X obj 105 66 + 1;
#X obj 45 18 inlet input_chip;
#X obj 77 158 outlet loop_times;
#X obj 168 478 outlet inlet_offset;
#X obj 45 263 outlet changed;
#X text 116 86 exclude non-existent table indices;
#X obj 45 88 moses 255;
#X obj 105 44 r num_modules;
#X text 222 260 a 0 won't make [until] run a loop so send it to [+
] in [pd compare-value] explicitly;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 4 0;
#X connect 2 0 1 1;
#X connect 3 0 1 1;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 5 0 17 0;
#X connect 6 0 5 1;
#X connect 7 0 5 1;
#X connect 8 0 0 0;
#X connect 8 1 3 0;
#X connect 8 2 7 0;
#X connect 9 0 17 0;
#X connect 9 1 8 0;
#X connect 10 0 16 0;
#X connect 11 0 13 0;
#X connect 11 1 10 0;
#X connect 13 0 18 0;
#X connect 13 1 9 0;
#X connect 14 0 20 1;
#X connect 15 0 20 0;
#X connect 20 0 11 0;
#X connect 21 0 14 0;
#X restore 140 90 pd num-of-loop-repetitions;
#X obj 17 13 r module3;
#X text 89 7 this name is due to the dynamic naming of [send] in the
teensy_data subpatch (the number is num_of_modules);
#X obj 17 415 s matrix_msg;
#X connect 0 0 1 0;
#X connect 1 0 8 0;
#X connect 1 0 14 0;
#X connect 2 0 3 0;
#X connect 3 0 17 0;
#X connect 4 0 21 0;
#X connect 5 0 15 0;
#X connect 6 0 5 1;
#X connect 7 0 1 1;
#X connect 8 0 1 1;
#X connect 10 0 5 0;
#X connect 10 1 6 0;
#X connect 10 2 17 3;
#X connect 10 3 18 0;
#X connect 12 0 0 0;
#X connect 13 0 12 0;
#X connect 13 1 7 0;
#X connect 13 2 2 1;
#X connect 13 3 17 2;
#X connect 14 0 2 0;
#X connect 14 1 17 1;
#X connect 15 0 13 0;
#X connect 17 0 4 0;
#X connect 18 0 15 1;
#X connect 18 1 12 1;
#X connect 18 2 17 4;
#X connect 19 0 10 0;
#X restore 45 334 pd set-connections;
#X obj 42 58 declare -lib /usr/lib/pd/extra/iemmatrix -lib /usr/lib/pd/extra/zexy
-path ./generic_abstractions -path ./modules -path ./modules/module_instances
;
#X obj 90 255 r to_comport;
#X text 180 254 various messages for Teensy;
#N canvas 247 89 822 376 matrix_msg 0;
#X obj 349 226 del;
#X obj 390 209 t f f;
#X obj 390 187 spigot;
#X obj 349 114 t f f;
#X text 317 39 when patching is deactivated \, send potentiometer values
to control ramp time for [mtx_*~];
#X obj 349 137 sel 1;
#X obj 317 91 t f f;
#X obj 271 68 t f f;
#X obj 317 69 r patchUpdate;
#X obj 390 164 r ramp;
#X msg 349 248 15;
#X text 378 242 when patching is reactivated \, delay a bang with the
potentiometer value to set [mtx_*~] back to 15ms;
#X obj 429 131 == 0;
#N canvas 180 51 1050 403 whole-matrix-and-data-diffusion 0;
#X obj 13 28 inlet;
#X text 77 282 matrix MUST have same dimensions as [mtx_*~];
#X obj 462 71 list split 2;
#X obj 502 96 unpack;
#X obj 124 344 mtx_print;
#X obj 124 322 spigot;
#X obj 163 303 tgl 15 0 empty empty debug 17 7 0 10 -262144 -1 -1 0
1;
#X text 19 248 constantly updated matrix that is output only when the
patching update is being REactivated;
#X obj 53 82 inlet;
#X text 104 106 bang matrix when patching update is reactivated;
#X obj 462 240 list split 1;
#X obj 541 119 t f f;
#X obj 13 54 t a a;
#X obj 53 105 sel 1;
#X obj 85 149 s reactivate;
#X obj 502 294 s inlet_states;
#X obj 502 272 pack;
#X obj 502 158 s outlet_states;
#X obj 502 136 pack;
#X obj 53 127 t b b;
#X obj 13 344 outlet;
#X obj 13 305 t a a;
#X obj 53 219 mtx_zeros 13 4;
#X obj 13 283 mtx 13 4;
#X text 152 194 zero the matrix on start up if the synth is already
patched;
#X obj 53 194 r zero_matrix;
#X text 104 129 and bang module abstractions to update on-off states
;
#X text 553 89 and send connection state to module abstractions to
control [switch~];
#X text 555 259 and send connection state to module abstractions to
turn a control signal on or off;
#X text 555 239 get matrix's outlet number;
#X text 555 70 get matrix's inlet number and connection state;
#X connect 0 0 12 0;
#X connect 2 0 10 0;
#X connect 2 1 3 0;
#X connect 3 0 18 0;
#X connect 3 1 11 0;
#X connect 5 0 4 0;
#X connect 6 0 5 1;
#X connect 8 0 13 0;
#X connect 10 1 16 0;
#X connect 11 0 18 1;
#X connect 11 1 16 1;
#X connect 12 0 23 0;
#X connect 12 1 2 0;
#X connect 13 0 19 0;
#X connect 16 0 15 0;
#X connect 18 0 17 0;
#X connect 19 0 23 0;
#X connect 19 1 14 0;
#X connect 21 0 20 0;
#X connect 21 1 5 0;
#X connect 22 0 23 0;
#X connect 23 0 21 0;
#X connect 25 0 22 0;
#X restore 68 95 pd whole-matrix-and-data-diffusion;
#X obj 36 73 t a a;
#X obj 36 125 spigot;
#X obj 36 187 s to_mtx_mul;
#X obj 36 147 t a a;
#X obj 135 187 print;
#X obj 135 164 spigot;
#X obj 174 144 tgl 15 0 empty empty debug 17 7 0 10 -262144 -1 -1 0
1;
#X obj 349 300 s mtx_ramp;
#X obj 36 51 r matrix_msg;
#X connect 0 0 10 0;
#X connect 1 0 0 1;
#X connect 1 1 21 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 3 1 12 0;
#X connect 5 0 0 0;
#X connect 6 0 7 0;
#X connect 6 1 3 0;
#X connect 7 0 15 1;
#X connect 7 1 13 1;
#X connect 8 0 6 0;
#X connect 9 0 2 0;
#X connect 10 0 21 0;
#X connect 12 0 2 1;
#X connect 13 0 16 0;
#X connect 14 0 15 0;
#X connect 14 1 13 0;
#X connect 15 0 17 0;
#X connect 17 0 16 0;
#X connect 17 1 19 0;
#X connect 17 1 18 0;
#X connect 19 0 18 0;
#X connect 20 0 19 1;
#X connect 22 0 14 0;
#X restore 45 380 pd matrix_msg;
#N canvas 90 51 308 219 matrix 0;
#N canvas 494 226 547 412 create_matrix 0;
#X obj 37 17 inlet do_it;
#X msg 69 62 clear;
#X obj 37 181 t b l;
#X obj 37 39 t b b;
#N canvas 0 51 371 323 make_cathes 0;
#X obj 116 149 + 100;
#X msg 116 194 obj \$1 50 catch~ output\$2;
#X obj 116 171 pack;
#X obj 116 105 t f f;
#X obj 91 59 v inlets;
#X obj 91 37 inlet;
#X obj 116 216 outlet make_obj;
#X obj 91 242 outlet done;
#X obj 116 127 * 110;
#X obj 91 82 loop;
#X connect 0 0 2 0;
#X connect 1 0 6 0;
#X connect 2 0 1 0;
#X connect 3 0 8 0;
#X connect 3 1 2 1;
#X connect 4 0 9 0;
#X connect 5 0 4 0;
#X connect 8 0 0 0;
#X connect 9 0 7 0;
#X connect 9 1 3 0;
#X restore 37 231 pd make_cathes;
#N canvas 0 51 343 309 make_sends 0;
#X obj 86 162 + 100;
#X obj 86 184 pack;
#X obj 86 118 t f f;
#X obj 86 140 * 100;
#X msg 86 207 obj \$1 150 send~ input\$2;
#X obj 61 73 v outlets;
#X obj 61 50 inlet;
#X obj 86 229 outlet make_obj;
#X obj 61 253 outlet done;
#X obj 61 95 loop;
#X connect 0 0 1 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 2 1 1 1;
#X connect 3 0 0 0;
#X connect 4 0 7 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 9 0 8 0;
#X connect 9 1 2 0;
#X restore 37 256 pd make_sends;
#N canvas 0 51 315 289 make_receives 0;
#X msg 109 122 obj 10 50 r to_mtx_mul;
#X msg 86 146 obj 10 150 r mtx_ramp;
#X obj 63 97 t b b b;
#X obj 63 71 inlet;
#X obj 109 175 outlet make_obj;
#X obj 63 197 outlet done;
#X connect 0 0 4 0;
#X connect 1 0 4 0;
#X connect 2 0 5 0;
#X connect 2 1 1 0;
#X connect 2 2 0 0;
#X connect 3 0 2 0;
#X restore 37 282 pd make_receives;
#N canvas 672 51 504 576 make_connections 0;
#X text 185 124 connect to [mtx_*~];
#X text 185 290 connect from [mtx_*~];
#X obj 35 10 inlet;
#X obj 35 32 v inlets;
#X obj 60 100 + 1;
#X msg 60 289 connect 0 \$1 \$2 0;
#X obj 35 156 v outlets;
#X obj 92 245 +;
#X obj 107 223 + 1;
#X msg 60 123 connect \$1 0 0 \$1;
#X obj 60 200 t f f;
#X obj 60 267 pack;
#X obj 35 54 t f f;
#X obj 35 340 v inlets;
#X obj 53 387 v outlets;
#X obj 35 409 +;
#X obj 35 431 + 1;
#X obj 35 453 t f f;
#X obj 35 475 + 1;
#X msg 105 470 connect \$1 0 0 0;
#X msg 35 523 connect \$1 0 0 \$2;
#X obj 35 362 t f f;
#X obj 67 475 + 1;
#X obj 35 499 pack;
#X obj 35 317 t b b;
#X obj 303 445 outlet connections;
#X obj 35 78 loop;
#X obj 35 179 loop;
#X connect 2 0 3 0;
#X connect 3 0 12 0;
#X connect 4 0 9 0;
#X connect 5 0 25 0;
#X connect 6 0 27 0;
#X connect 7 0 11 1;
#X connect 8 0 7 1;
#X connect 9 0 25 0;
#X connect 10 0 11 0;
#X connect 10 1 7 0;
#X connect 11 0 5 0;
#X connect 12 0 26 0;
#X connect 12 1 8 0;
#X connect 13 0 21 0;
#X connect 14 0 15 1;
#X connect 15 0 16 0;
#X connect 16 0 17 0;
#X connect 17 0 18 0;
#X connect 17 1 19 0;
#X connect 18 0 23 0;
#X connect 19 0 25 0;
#X connect 20 0 25 0;
#X connect 21 0 15 0;
#X connect 21 1 22 0;
#X connect 22 0 23 1;
#X connect 23 0 20 0;
#X connect 24 0 13 0;
#X connect 24 1 14 0;
#X connect 26 0 6 0;
#X connect 26 1 4 0;
#X connect 27 0 24 0;
#X connect 27 1 10 0;
#X restore 37 307 pd make_connections;
#X obj 37 87 t b b;
#X obj 37 159 pack;
#X obj 69 109 v inlets;
#X obj 37 133 v outlets;
#X msg 220 198 obj 100 100 mtx_*~ \$1 \$2 15 ...........................................
;
#X obj 220 248 s pd-the_matrix;
#X connect 0 0 3 0;
#X connect 1 0 13 0;
#X connect 2 0 4 0;
#X connect 2 1 12 0;
#X connect 3 0 8 0;
#X connect 3 1 1 0;
#X connect 4 0 5 0;
#X connect 4 1 13 0;
#X connect 5 0 6 0;
#X connect 5 1 13 0;
#X connect 6 0 7 0;
#X connect 6 1 13 0;
#X connect 7 0 13 0;
#X connect 8 0 11 0;
#X connect 8 1 10 0;
#X connect 9 0 2 0;
#X connect 10 0 9 1;
#X connect 11 0 9 0;
#X connect 12 0 13 0;
#X restore 24 87 pd create_matrix;
#X msg 24 64 bang;
#X text 58 65 <- create new matrix;
#N canvas 5 222 1234 315 the_matrix 0;
#X obj 100 100 mtx_*~ 13 4 15 ...........................................
;
#X obj 100 50 catch~ output0;
#X obj 210 50 catch~ output1;
#X obj 320 50 catch~ output2;
#X obj 430 50 catch~ output3;
#X obj 100 150 send~ input0;
#X obj 200 150 send~ input1;
#X obj 300 150 send~ input2;
#X obj 400 150 send~ input3;
#X obj 500 150 send~ input4;
#X obj 600 150 send~ input5;
#X obj 700 150 send~ input6;
#X obj 800 150 send~ input7;
#X obj 900 150 send~ input8;
#X obj 1000 150 send~ input9;
#X obj 1100 150 send~ input10;
#X obj 1200 150 send~ input11;
#X obj 1300 150 send~ input12;
#X obj 10 50 r to_mtx_mul;
#X obj 10 150 r mtx_ramp;
#X connect 0 0 5 0;
#X connect 0 1 6 0;
#X connect 0 2 7 0;
#X connect 0 3 8 0;
#X connect 0 4 9 0;
#X connect 0 5 10 0;
#X connect 0 6 11 0;
#X connect 0 7 12 0;
#X connect 0 8 13 0;
#X connect 0 9 14 0;
#X connect 0 10 15 0;
#X connect 0 11 16 0;
#X connect 0 12 17 0;
#X connect 1 0 0 1;
#X connect 2 0 0 2;
#X connect 3 0 0 3;
#X connect 4 0 0 4;
#X connect 18 0 0 0;
#X connect 19 0 0 5;
#X restore 24 109 pd the_matrix;
#X connect 1 0 0 0;
#X restore 45 403 pd matrix;
#N canvas 567 51 500 335 modules 0;
#X text 41 18 Module abstraction arguments:;
#X text 40 35 1st: module number \, starting from 0;
#X text 40 53 2nd: number of inlets (output shift registers);
#X text 40 120 4th: number of outlets (input shift registers);
#X obj 43 218 pow_sine~ 1 3 7 1 1;
#X obj 43 240 adc_dac~ 2 3 10 2 2;
#X obj 43 196 var_shapes~ 0 7 0 1 0;
#X text 40 72 3rd: number of first inlet (output shift register) in
the matrix ([mtx_*~] outlet) \, starting from 0 (sum of args 2 and
3 of previous abstraction);
#X text 40 141 5th: number of first outlet (input shift registers)
in the matrix ([mtx_*~] inlet) \, starting from 0 (sum of args 4 and
5 of previous abstraction);
#X restore 45 426 pd modules;
#X connect 2 0 10 0;
#X connect 7 0 10 0;
#X connect 8 0 10 0;
#X connect 9 0 10 0;
#X connect 15 0 10 0;
