#N canvas 120 203 507 395 10;
#X declare -path ../generic_abstractions;
#X declare -path ../generic_abstractions;
#X declare -path ../generic_abstractions;
#X declare -lib /usr/lib/pd/extra/iemmatrix -lib /usr/lib/pd/extra/zexy
-path ./generic_abstractions -path ./modules;
#N canvas 497 97 559 505 serial-communication 0;
#X obj 14 185 select 192;
#X obj 81 319 spigot;
#X msg 120 296 0;
#X msg 14 244 1;
#X obj 37 375 spigot;
#X msg 53 244 0;
#X obj 14 219 t b b b;
#X obj 14 42 inlet;
#X text 119 239 after data transfer package received \, close spigot
till package initialiser received;
#X obj 37 397 outlet;
#X obj 249 69 inlet;
#X text 89 181 This is 0xc0 in the Arduino code which denotes the beginning
of the data stream;
#X obj 301 69 r pd;
#X obj 301 91 route dsp;
#X text 374 92 control the DSP LED;
#X obj 14 266 t f f;
#X msg 301 113 print \$1;
#X obj 26 68 inlet;
#X msg 26 90 open \$1;
#X obj 174 339 spigot;
#X obj 241 382 t l b;
#X obj 241 404 print;
#X obj 213 318 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X text 222 339 debug input;
#X obj 120 271 r close-comport;
#X obj 174 361 route bang;
#X obj 103 70 inlet devicename;
#X obj 37 347 repack 31;
#X msg 103 92 devicename \$1;
#X obj 14 162 comport 0 115200;
#X connect 0 0 6 0;
#X connect 0 1 1 0;
#X connect 1 0 27 0;
#X connect 2 0 1 1;
#X connect 3 0 15 0;
#X connect 4 0 9 0;
#X connect 5 0 4 1;
#X connect 6 0 3 0;
#X connect 6 1 27 0;
#X connect 6 2 5 0;
#X connect 7 0 29 0;
#X connect 10 0 29 0;
#X connect 12 0 13 0;
#X connect 13 0 16 0;
#X connect 15 0 4 1;
#X connect 15 1 1 1;
#X connect 16 0 29 0;
#X connect 17 0 18 0;
#X connect 18 0 29 0;
#X connect 19 0 25 0;
#X connect 20 0 21 0;
#X connect 20 1 22 0;
#X connect 22 0 19 1;
#X connect 24 0 2 0;
#X connect 25 1 20 0;
#X connect 26 0 28 0;
#X connect 27 0 4 0;
#X connect 27 0 19 0;
#X connect 28 0 29 0;
#X connect 29 0 0 0;
#X restore 45 290 pd serial-communication;
#N canvas 469 282 285 201 receivedData 0;
#X obj 15 30 inlet;
#N canvas 127 151 1034 509 comparison-tables 0;
#X msg 595 136 resize \$1;
#X floatatom 116 350 5 0 0 2 index - -, f 5;
#X floatatom 63 350 5 0 0 2 value - -, f 5;
#X obj 432 33 loadbang;
#X obj 557 245 v num_of_modules;
#X floatatom 534 26 5 0 0 2 num_of_modules - -, f 5;
#X msg 182 345 store;
#X msg 186 368 read;
#X obj 618 203 s switch_pins;
#X obj 595 223 s num_of_switches;
#X symbolatom 11 319 16 0 0 2 set_table - -, f 16;
#X msg 185 389 clear;
#X msg 534 97 3;
#X obj 11 338 t s b;
#N canvas 412 385 731 346 create-tables 0;
#X obj 268 114 until;
#X obj 268 157 f;
#X obj 298 158 + 1;
#X obj 291 201 * 20;
#X msg 286 136 0;
#X obj 291 223 + 10;
#X obj 291 245 pack;
#X obj 291 290 s pd-tables;
#X msg 291 268 obj 300 \$1 table previous_states\$2;
#X obj 26 76 sel;
#X obj 268 179 t f f f;
#X obj 26 143 until;
#X obj 26 186 f;
#X obj 56 187 + 1;
#X msg 44 163 0;
#X obj 26 208 pack;
#X msg 26 230 \; previous_states\$1 resize \$2;
#X obj 44 55 - 1;
#X obj 26 121 t f b;
#X obj 26 99 v outlets;
#X obj 127 191 v inlets;
#X msg 268 43 bang;
#X obj 95 59 t b b;
#X obj 95 37 inlet;
#X text 94 19 set size of previous states tables;
#X text 299 43 create previous state tables (if they don't already
exist);
#X obj 268 66 v outlets;
#X obj 268 89 t f b f;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 10 0;
#X connect 2 0 1 1;
#X connect 3 0 5 0;
#X connect 4 0 1 1;
#X connect 5 0 6 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X connect 9 0 19 0;
#X connect 10 0 9 0;
#X connect 10 1 3 0;
#X connect 10 2 6 1;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 12 0 15 0;
#X connect 13 0 12 1;
#X connect 14 0 12 1;
#X connect 15 0 16 0;
#X connect 17 0 9 1;
#X connect 18 0 11 0;
#X connect 18 1 14 0;
#X connect 19 0 18 0;
#X connect 20 0 15 1;
#X connect 21 0 26 0;
#X connect 22 0 19 0;
#X connect 22 1 20 0;
#X connect 23 0 22 0;
#X connect 26 0 27 0;
#X connect 27 0 0 0;
#X connect 27 1 4 0;
#X connect 27 2 17 0;
#X restore 455 412 pd create-tables;
#X obj 534 45 t b f;
#X msg 566 66 set \$1;
#X obj 595 158 t a a a;
#X obj 641 182 s input_pins;
#X msg 548 310 4;
#X obj 548 332 v inlets;
#X obj 510 363 v outlets;
#X text 579 363 number of outlets and inlets of [mtx_*~];
#X obj 432 80 t b b b;
#X obj 455 293 t b b b;
#X text 9 65 switch_pins table should store the pin the first switch
is attached to on each module \, starting from 0;
#X text 9 101 num_of_switches table should store the number of switches
on each module;
#X msg 175 324 manual;
#X msg 169 302 automatic;
#X text 238 302 index;
#X text 224 325 index;
#X text 226 345 values;
#X text 223 368 values;
#X text 228 389 [textfile];
#N canvas 340 64 702 626 set-values-to-tables 0;
#X obj 21 314 tabwrite;
#X obj 121 206 t b b;
#X obj 103 297 f;
#X obj 133 298 + 1;
#X msg 121 275 0;
#X obj 39 234 t f b;
#X obj 103 251 spigot;
#X msg 142 229 1;
#X msg 175 205 0;
#X obj 21 4 inlet which_table;
#X obj 39 110 inlet value;
#X obj 74 135 inlet index;
#X obj 21 53 list prepend set;
#X obj 21 75 list trim;
#X obj 229 379 textfile;
#X msg 337 206 clear;
#X msg 195 299 write ./data/tables.txt;
#X msg 205 277 add \$1;
#X msg 249 351 rewind;
#X msg 269 329 read ./data/tables.txt;
#X obj 21 26 t s b s;
#X obj 261 572 s;
#X msg 289 274 1;
#X obj 241 464 spigot;
#X msg 314 396 0;
#X msg 461 330 symbol write;
#X msg 261 532 \$2 ./data/\$1.txt;
#X obj 261 509 pack s s;
#X obj 229 250 t b b b b;
#X obj 229 206 t b b;
#X obj 283 206 t b b;
#X msg 462 306 symbol read;
#X text 293 366 store table names to a text file to be able to call
them automatically;
#X obj 229 401 t b a;
#X obj 288 555 symbol;
#X obj 261 486 t a a;
#X obj 121 161 inlet features;
#X obj 121 184 route automatic manual store read clear;
#X connect 1 0 4 0;
#X connect 1 1 7 0;
#X connect 2 0 3 0;
#X connect 2 0 0 1;
#X connect 3 0 2 1;
#X connect 4 0 2 1;
#X connect 5 0 0 0;
#X connect 5 1 6 0;
#X connect 6 0 2 0;
#X connect 7 0 6 1;
#X connect 8 0 6 1;
#X connect 9 0 20 0;
#X connect 10 0 5 0;
#X connect 11 0 0 1;
#X connect 12 0 13 0;
#X connect 13 0 0 0;
#X connect 14 0 33 0;
#X connect 14 1 24 0;
#X connect 15 0 14 0;
#X connect 16 0 14 0;
#X connect 17 0 14 0;
#X connect 18 0 14 0;
#X connect 19 0 14 0;
#X connect 20 0 12 0;
#X connect 20 1 16 0;
#X connect 20 2 17 0;
#X connect 22 0 23 1;
#X connect 23 0 14 0;
#X connect 24 0 23 1;
#X connect 25 0 27 1;
#X connect 26 0 21 0;
#X connect 27 0 26 0;
#X connect 28 0 14 0;
#X connect 28 1 18 0;
#X connect 28 2 19 0;
#X connect 28 3 22 0;
#X connect 29 0 28 0;
#X connect 29 1 25 0;
#X connect 30 0 28 0;
#X connect 30 1 31 0;
#X connect 31 0 27 1;
#X connect 33 0 23 0;
#X connect 33 1 35 0;
#X connect 34 0 21 1;
#X connect 35 0 27 0;
#X connect 35 1 34 0;
#X connect 36 0 37 0;
#X connect 37 0 1 0;
#X connect 37 1 8 0;
#X connect 37 2 29 0;
#X connect 37 3 30 0;
#X connect 37 4 15 0;
#X restore 11 369 pd set-values-to-tables;
#X msg 478 319 12;
#X msg 443 55 bang;
#N canvas 460 69 513 492 tables 0;
#X obj 18 32 table switch_pins;
#X obj 18 52 table num_of_switches;
#X obj 18 12 table input_pins;
#X obj 300 10 table previous_states0;
#X obj 300 30 table previous_states1;
#X obj 300 50 table previous_states2;
#X obj 300 70 table previous_states3;
#X obj 300 90 table previous_states4;
#X obj 300 110 table previous_states5;
#X obj 300 130 table previous_states6;
#X obj 300 150 table previous_states7;
#X obj 300 170 table previous_states8;
#X obj 300 190 table previous_states9;
#X obj 300 210 table previous_states10;
#X obj 300 230 table previous_states11;
#X restore 10 273 pd tables;
#N canvas 573 239 311 279 zero-previous_states 0;
#X obj 75 15 inlet;
#X obj 75 37 v outlets;
#X obj 75 81 until;
#X obj 75 124 f;
#X obj 105 125 + 1;
#X msg 93 103 0;
#X obj 75 146 t b f;
#X msg 107 193 symbol previous_states\$1;
#X msg 75 168 const 0;
#X obj 75 210 s;
#X obj 75 59 t f b b;
#X obj 121 81 s matrix;
#X connect 0 0 1 0;
#X connect 1 0 10 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 3 1;
#X connect 5 0 3 1;
#X connect 6 0 8 0;
#X connect 6 1 7 0;
#X connect 7 0 9 1;
#X connect 8 0 9 0;
#X connect 10 0 2 0;
#X connect 10 1 5 0;
#X connect 10 2 11 0;
#X restore 455 458 pd zero-previous_states;
#X msg 455 435 bang;
#X obj 534 119 t f f f;
#X obj 478 341 t f f;
#X text 589 386 goes into [pd compare-value] inside [pd set-connections]
;
#X obj 534 267 s num_modules;
#X text 632 263 goes into [pd num-of-loop-repetitions] inside [pd set-connections]
and in [pd get-switches];
#X obj 478 386 s num_outlets;
#X text 10 26 input_pins table should store the number of input pins
used on each module;
#X text 9 137 previous_states\$1 tables store the states of connections.
\$1 is the outlet number of [mtx_*~] and the table's size is the number
of inlets of [mtx_*~] so you get a unique value for all possible connections.
these tables are used in the [pd set-connections] \, where their values
are compared to incoming values. if they are the same \, set-connection
won't output anything \, if they are different \, [pd set-connections]
will output a matrix message of the form "element \$1 \$2 \$3" and
it will store the new connection to the corresponding previous_states\$1
table \, at the corresponding index;
#X connect 0 0 17 0;
#X connect 1 0 34 2;
#X connect 2 0 34 1;
#X connect 3 0 23 0;
#X connect 5 0 15 0;
#X connect 6 0 34 3;
#X connect 7 0 34 3;
#X connect 10 0 13 0;
#X connect 11 0 34 3;
#X connect 12 0 40 0;
#X connect 13 0 34 0;
#X connect 13 1 28 0;
#X connect 15 0 12 0;
#X connect 15 1 16 0;
#X connect 16 0 12 0;
#X connect 17 0 9 0;
#X connect 17 1 8 0;
#X connect 17 2 18 0;
#X connect 19 0 20 0;
#X connect 23 0 7 0;
#X connect 23 1 24 0;
#X connect 23 2 12 0;
#X connect 24 0 14 0;
#X connect 24 1 35 0;
#X connect 24 2 19 0;
#X connect 27 0 34 3;
#X connect 28 0 34 3;
#X connect 35 0 41 0;
#X connect 36 0 23 0;
#X connect 39 0 38 0;
#X connect 40 0 43 0;
#X connect 40 1 4 0;
#X connect 40 2 0 0;
#X connect 41 0 45 0;
#X connect 41 1 21 0;
#X restore 15 122 pd comparison-tables;
#N canvas 665 53 384 269 digital 0;
#X obj 49 57 inlet;
#N canvas 172 113 775 537 get-switches 0;
#X obj 21 207 until;
#X obj 53 369 f;
#X obj 53 394 &;
#X obj 53 416 == 0;
#X obj 21 11 inlet;
#X obj 21 33 unpack f f f;
#X obj 290 188 tabread switch_pins;
#X obj 313 165 tabread num_of_switches;
#X obj 21 72 +;
#X obj 61 55 * 128;
#X text 61 9 incoming bytes are input byte and input chip #;
#X obj 21 441 pack f f f;
#X msg 21 463 \$3 \$1 \$2;
#X obj 267 114 t f f f;
#X obj 89 302 swap 2;
#X obj 89 324 pow;
#X obj 85 369 * 2;
#X obj 21 182 f;
#X obj 290 212 t f f;
#X obj 21 250 f;
#X obj 51 251 + 1;
#X obj 21 293 t f b;
#X text 76 252 start from # of pin the first switch is attached to
;
#X text 322 135 loop for as many times as the number of switches attached
to the current chip;
#X text 87 463 spit input chip # with switch index and value;
#N canvas 769 148 245 249 switch-changed1 0;
#X obj 125 88 f;
#X obj 65 62 t f f f b;
#X obj 85 105 !=;
#X obj 139 187 spigot;
#X obj 85 127 t f f;
#X obj 65 39 inlet;
#X obj 139 209 outlet;
#X obj 85 209 outlet;
#X connect 0 0 2 1;
#X connect 1 0 3 0;
#X connect 1 1 2 0;
#X connect 1 2 0 1;
#X connect 1 3 0 0;
#X connect 2 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 4 1 3 1;
#X connect 5 0 1 0;
#X restore 144 50 pd switch-changed1;
#N canvas 29 146 568 391 switch-changed2 0;
#X obj 34 66 inlet;
#X obj 34 88 t b f;
#X obj 90 68 > 0;
#X obj 34 128 spigot;
#X obj 149 105 t f f f b;
#X obj 209 130 f;
#X obj 169 147 !=;
#X obj 149 269 spigot;
#X obj 149 291 f;
#X obj 149 313 outlet;
#X obj 169 169 t f f;
#X obj 34 216 spigot;
#X obj 73 195 == 0;
#X text 115 69 if the other value has changed open the [spigot] below
;
#X text 85 212 if this value has changed you don't need to bang it
\, if it hasn't \, you should bang it if the other has changed;
#X obj 90 45 inlet changed;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 4 0;
#X connect 2 0 3 1;
#X connect 3 0 11 0;
#X connect 4 0 7 0;
#X connect 4 1 6 0;
#X connect 4 2 5 1;
#X connect 4 3 5 0;
#X connect 5 0 6 1;
#X connect 6 0 10 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 1 7 1;
#X connect 11 0 8 0;
#X connect 12 0 11 1;
#X connect 15 0 2 0;
#X restore 21 94 pd switch-changed2;
#X obj 39 229 f;
#X obj 71 347 f;
#X obj 21 159 t b b f b;
#X text 115 337 values read from tables need to be stored in a variable
cause they won't be output if they don't change and that will cause
an overflow;
#X obj 267 89 moses 255;
#X obj 327 45 r num_modules;
#X obj 327 67 + 1;
#X text 336 89 exclude non-existent table indices;
#X obj 21 484 s switches;
#X connect 0 0 19 0;
#X connect 1 0 16 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 11 1;
#X connect 4 0 5 0;
#X connect 5 0 8 0;
#X connect 5 1 9 0;
#X connect 5 2 25 0;
#X connect 6 0 18 0;
#X connect 7 0 17 1;
#X connect 8 0 26 0;
#X connect 9 0 8 1;
#X connect 11 0 12 0;
#X connect 12 0 35 0;
#X connect 13 0 11 2;
#X connect 13 1 6 0;
#X connect 13 2 7 0;
#X connect 14 0 15 0;
#X connect 14 1 15 1;
#X connect 15 0 28 1;
#X connect 16 0 1 1;
#X connect 17 0 0 0;
#X connect 18 0 27 1;
#X connect 18 1 14 0;
#X connect 19 0 20 0;
#X connect 19 0 21 0;
#X connect 20 0 19 1;
#X connect 21 0 11 0;
#X connect 21 1 1 0;
#X connect 25 0 26 1;
#X connect 25 1 31 0;
#X connect 26 0 29 0;
#X connect 27 0 19 1;
#X connect 28 0 1 1;
#X connect 29 0 17 0;
#X connect 29 1 27 0;
#X connect 29 2 2 1;
#X connect 29 3 28 0;
#X connect 31 0 13 0;
#X connect 32 0 33 0;
#X connect 33 0 31 1;
#X restore 89 148 pd get-switches;
#X obj 49 79 list split 4;
#N canvas 609 62 525 509 set-connections 0;
#X obj 17 13 inlet;
#X obj 17 226 until;
#X obj 17 272 f;
#X obj 17 356 &;
#X obj 17 378 == 0;
#X msg 17 433 element \$3 \$2 \$1;
#X obj 17 128 +;
#X obj 35 105 * 128;
#X msg 35 249 1;
#X obj 49 272 * 2;
#X text 22 322 bitwise AND with 1 \, 2 \, 4 \, 8 \, 16 \, 32... and
check for inequality with zero;
#X obj 17 38 unpack f f f f;
#X text 57 6 incoming bytes refer to input byte \, output pin # and
input chip #;
#X obj 17 202 f;
#X obj 17 179 t b b f b;
#X obj 17 297 t f b;
#N canvas 433 206 526 362 banana-changed2 0;
#X obj 34 66 inlet;
#X obj 34 88 t b f;
#X obj 90 65 > 0;
#X obj 34 128 spigot;
#X obj 149 105 t f f f b;
#X obj 209 130 f;
#X obj 166 147 !=;
#X obj 149 269 spigot;
#X obj 149 291 f;
#X obj 149 313 outlet;
#X obj 166 169 t f f;
#X obj 34 216 spigot;
#X obj 73 194 == 0;
#X text 116 60 if the other value has changed open the [spigot] below
;
#X text 84 212 if this value has changed you don't need to bang it
\, if it hasn't \, you should bang it if the other has changed;
#X obj 90 43 inlet;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 4 0;
#X connect 2 0 3 1;
#X connect 3 0 11 0;
#X connect 4 0 7 0;
#X connect 4 1 6 0;
#X connect 4 2 5 1;
#X connect 4 3 5 0;
#X connect 5 0 6 1;
#X connect 6 0 10 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 1 7 1;
#X connect 11 0 8 0;
#X connect 12 0 11 1;
#X connect 15 0 2 0;
#X restore 17 155 pd banana-changed2;
#X text 61 205 run the loop for as many times as the number of pins
used of current input chip;
#N canvas 17 107 602 518 compare-value 0;
#X obj 52 308 t f f;
#X obj 91 331 !=;
#X obj 52 359 spigot;
#X obj 52 381 t f f;
#X msg 245 144 set previous_states\$1;
#X obj 109 304 tabread;
#X obj 277 398 tabwrite;
#X obj 245 166 t a a;
#X obj 85 189 f;
#X obj 115 189 + 1;
#X msg 103 166 0;
#X obj 85 234 +;
#X text 342 397 store altered state;
#X obj 85 422 + 1;
#X text 146 421 + 1 cause [mtx_*~] starts counting from 1;
#X obj 245 121 t f f;
#X obj 119 422 + 1;
#X obj 85 256 t f f f;
#X text 165 303 compare stored state of connection;
#X obj 305 74 + 1;
#X obj 52 83 inlet value;
#X obj 85 113 inlet bang_until;
#X obj 103 141 inlet bang_once;
#X obj 245 25 inlet which_outlet;
#X obj 52 450 pack f f f;
#X obj 52 472 outlet;
#X obj 386 217 inlet inlet_offset;
#X text 315 95 exclude values of non-existent tables;
#X obj 245 96 moses 255;
#X obj 305 52 r num_outlets;
#X connect 0 0 2 0;
#X connect 0 1 1 0;
#X connect 1 0 2 1;
#X connect 2 0 3 0;
#X connect 3 0 24 0;
#X connect 3 1 6 0;
#X connect 4 0 7 0;
#X connect 5 0 1 1;
#X connect 7 0 5 0;
#X connect 7 1 6 0;
#X connect 8 0 9 0;
#X connect 8 0 11 0;
#X connect 9 0 8 1;
#X connect 10 0 8 1;
#X connect 11 0 17 0;
#X connect 13 0 24 1;
#X connect 15 0 4 0;
#X connect 15 1 16 0;
#X connect 16 0 24 2;
#X connect 17 0 13 0;
#X connect 17 1 5 0;
#X connect 17 2 6 1;
#X connect 19 0 28 1;
#X connect 20 0 0 0;
#X connect 21 0 8 0;
#X connect 22 0 10 0;
#X connect 23 0 28 0;
#X connect 24 0 25 0;
#X connect 26 0 11 1;
#X connect 28 0 15 0;
#X connect 29 0 19 0;
#X restore 17 404 pd compare-value;
#N canvas 12 151 699 553 num-of-loop-repetitions 0;
#X obj 214 317 until;
#X obj 214 361 f;
#X obj 244 361 + 1;
#X msg 232 339 0;
#X obj 214 384 tabread input_pins;
#X obj 214 428 +;
#X obj 244 428 f;
#X msg 232 406 0;
#X obj 214 295 t f b b;
#X obj 168 262 moses 1;
#X obj 77 136 tabread input_pins;
#X obj 45 113 t f f;
#X text 53 207 accumulate used input pins of previous chips to set
correct inlet number offset;
#N canvas 271 341 172 238 banana-changed1 0;
#X obj 105 88 f;
#X obj 45 62 t f f f b;
#X obj 65 105 !=;
#X obj 58 157 spigot;
#X obj 65 127 t f f;
#X obj 45 39 inlet;
#X obj 58 179 outlet;
#X obj 8 179 outlet;
#X connect 0 0 2 1;
#X connect 1 0 3 0;
#X connect 1 1 2 0;
#X connect 1 2 0 1;
#X connect 1 3 0 0;
#X connect 2 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 4 1 3 1;
#X connect 5 0 1 0;
#X restore 45 239 pd banana-changed1;
#X obj 105 66 + 1;
#X obj 45 18 inlet input_chip;
#X obj 77 158 outlet loop_times;
#X obj 168 478 outlet inlet_offset;
#X obj 45 263 outlet changed;
#X text 116 86 exclude non-existent table indices;
#X obj 45 88 moses 255;
#X obj 105 44 r num_modules;
#X text 222 260 a 0 won't make [until] run a loop so send it to [+
] in [pd compare-value] explicitly;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 4 0;
#X connect 2 0 1 1;
#X connect 3 0 1 1;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 5 0 17 0;
#X connect 6 0 5 1;
#X connect 7 0 5 1;
#X connect 8 0 0 0;
#X connect 8 1 3 0;
#X connect 8 2 7 0;
#X connect 9 0 17 0;
#X connect 9 1 8 0;
#X connect 10 0 16 0;
#X connect 11 0 13 0;
#X connect 11 1 10 0;
#X connect 13 0 18 0;
#X connect 13 1 9 0;
#X connect 14 0 20 1;
#X connect 15 0 20 0;
#X connect 20 0 11 0;
#X connect 21 0 14 0;
#X restore 140 133 pd num-of-loop-repetitions;
#X obj 17 60 t f b;
#X obj 44 82 s toComport;
#X obj 17 458 outlet;
#X connect 0 0 11 0;
#X connect 1 0 2 0;
#X connect 2 0 9 0;
#X connect 2 0 15 0;
#X connect 3 0 4 0;
#X connect 4 0 18 0;
#X connect 5 0 22 0;
#X connect 6 0 16 0;
#X connect 7 0 6 1;
#X connect 8 0 2 1;
#X connect 9 0 2 1;
#X connect 11 0 20 0;
#X connect 11 1 7 0;
#X connect 11 2 18 3;
#X connect 11 3 19 0;
#X connect 13 0 1 0;
#X connect 14 0 13 0;
#X connect 14 1 8 0;
#X connect 14 2 3 1;
#X connect 14 3 18 2;
#X connect 15 0 3 0;
#X connect 15 1 18 1;
#X connect 16 0 14 0;
#X connect 18 0 5 0;
#X connect 19 0 16 1;
#X connect 19 1 13 1;
#X connect 19 2 18 4;
#X connect 20 0 6 0;
#X connect 20 1 21 0;
#X restore 49 171 pd set-connections;
#X obj 89 103 list split 3;
#X obj 129 126 outlet rest_of_data;
#X obj 49 193 outlet;
#X connect 0 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 3 0 6 0;
#X connect 4 0 1 0;
#X connect 4 1 5 0;
#X restore 15 53 pd digital;
#X obj 82 75 outlet arduino_data;
#X obj 15 99 outlet matrix_msg;
#X connect 0 0 2 0;
#X connect 2 0 4 0;
#X connect 2 1 3 0;
#X restore 45 312 pd receivedData;
#X text 202 245 close serial port;
#N canvas 663 107 478 434 audio-engine 0;
#X obj 31 217 inlet;
#N canvas 280 110 822 376 receive_and_collect_matrix_msg 0;
#X obj 349 226 del;
#X obj 390 209 t f f;
#X obj 390 187 spigot;
#X obj 349 114 t f f;
#X text 317 39 when patching is deactivated \, send potentiometer values
to control ramp time for [mtx_*~];
#X obj 349 137 sel 1;
#X obj 317 91 t f f;
#X obj 271 68 t f f;
#X obj 317 69 r patchUpdate;
#X obj 390 164 r ramp;
#X msg 349 248 15;
#X text 378 242 when patching is reactivated \, delay a bang with the
potentiometer value to set [mtx_*~] back to 15ms;
#X obj 429 131 == 0;
#N canvas 160 51 1050 403 whole-matrix-and-data-diffusion 0;
#X obj 13 28 inlet;
#X text 77 266 matrix MUST have same dimensions as [mtx_*~];
#X obj 462 71 list split 2;
#X obj 502 96 unpack;
#X text 555 71 get inlet number and connection state;
#X obj 124 328 mtx_print;
#X obj 124 306 spigot;
#X obj 163 287 tgl 15 0 empty empty debug 17 7 0 10 -262144 -1 -1 0
1;
#X text 19 232 constantly updated matrix that is output only when the
patching update is being REactivated;
#X obj 53 82 inlet;
#X text 104 106 bang matrix when patching update is reactivated;
#X obj 462 240 list split 1;
#X obj 541 119 t f f;
#X obj 13 54 t a a;
#X obj 53 105 sel 1;
#X text 555 239 get outlet number;
#X text 553 90 and send connection state to corresponding "module"
to control [switch~];
#X text 545 257 send connection state to corresponding subpatch of
corresponding "module" to turn a control signal on or off;
#X obj 13 267 mtx 12 4;
#X obj 85 149 s reactivate;
#X text 104 129 and bang subpatches of nodes to update on-off states
;
#X obj 85 173 r matrix;
#X obj 85 195 mtx_zeros 12 4;
#X text 146 174 zero the matrix in case the Teensy goes crazy;
#X obj 502 294 s inlet_states;
#X obj 502 272 pack;
#X obj 502 158 s outlet_states;
#X obj 502 136 pack;
#X text 612 159 states of modules outlets connections (matrix's inlets)
;
#X text 607 296 states of modules inlets connections (matrix's outlets)
;
#X obj 53 127 t b b;
#X obj 13 328 outlet;
#X obj 13 289 t a a;
#X connect 0 0 13 0;
#X connect 2 0 11 0;
#X connect 2 1 3 0;
#X connect 3 0 27 0;
#X connect 3 1 12 0;
#X connect 6 0 5 0;
#X connect 7 0 6 1;
#X connect 9 0 14 0;
#X connect 11 1 25 0;
#X connect 12 0 27 1;
#X connect 12 1 25 1;
#X connect 13 0 18 0;
#X connect 13 1 2 0;
#X connect 14 0 30 0;
#X connect 18 0 32 0;
#X connect 21 0 22 0;
#X connect 22 0 18 0;
#X connect 25 0 24 0;
#X connect 27 0 26 0;
#X connect 30 0 18 0;
#X connect 30 1 19 0;
#X connect 32 0 31 0;
#X connect 32 1 6 0;
#X restore 68 95 pd whole-matrix-and-data-diffusion;
#X obj 36 51 inlet;
#X obj 36 73 t a a;
#X obj 36 125 spigot;
#X obj 36 187 s to_mtx_mul;
#X obj 36 147 t a a;
#X obj 135 187 print;
#X obj 135 164 spigot;
#X obj 174 144 tgl 15 0 empty empty debug 17 7 0 10 -262144 -1 -1 0
1;
#X obj 349 300 s mtx_ramp;
#X connect 0 0 10 0;
#X connect 1 0 0 1;
#X connect 1 1 22 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 3 1 12 0;
#X connect 5 0 0 0;
#X connect 6 0 7 0;
#X connect 6 1 3 0;
#X connect 7 0 16 1;
#X connect 7 1 13 1;
#X connect 8 0 6 0;
#X connect 9 0 2 0;
#X connect 10 0 22 0;
#X connect 12 0 2 1;
#X connect 13 0 17 0;
#X connect 14 0 15 0;
#X connect 15 0 16 0;
#X connect 15 1 13 0;
#X connect 16 0 18 0;
#X connect 18 0 17 0;
#X connect 18 1 20 0;
#X connect 20 0 19 0;
#X connect 21 0 20 1;
#X restore 31 239 pd receive_and_collect_matrix_msg;
#X obj 286 217 inlet;
#N canvas 509 236 547 412 create_matrix 0;
#X obj 37 17 inlet do_it;
#X obj 220 248 s pd-matrix;
#X msg 69 62 clear;
#X obj 37 181 t b l;
#X obj 37 39 t b b;
#N canvas 0 51 371 323 make_cathes 0;
#X obj 116 149 + 100;
#X msg 116 194 obj \$1 50 catch~ output\$2;
#X obj 116 171 pack;
#X obj 116 105 t f f;
#X obj 116 127 * 100;
#X obj 91 59 v inlets;
#X obj 91 37 inlet;
#X obj 116 216 outlet make_obj;
#X obj 91 242 outlet done;
#X obj 91 82 loop;
#X connect 0 0 2 0;
#X connect 1 0 7 0;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 3 1 2 1;
#X connect 4 0 0 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 9 0 8 0;
#X connect 9 1 3 0;
#X restore 37 231 pd make_cathes;
#N canvas 0 51 343 309 make_sends 0;
#X obj 61 95 loop;
#X obj 86 162 + 100;
#X obj 86 184 pack;
#X obj 86 118 t f f;
#X obj 86 140 * 100;
#X msg 86 207 obj \$1 150 send~ input\$2;
#X obj 61 73 v outlets;
#X obj 61 50 inlet;
#X obj 86 229 outlet make_obj;
#X obj 61 253 outlet done;
#X connect 0 0 9 0;
#X connect 0 1 3 0;
#X connect 1 0 2 0;
#X connect 2 0 5 0;
#X connect 3 0 4 0;
#X connect 3 1 2 1;
#X connect 4 0 1 0;
#X connect 5 0 8 0;
#X connect 6 0 0 0;
#X connect 7 0 6 0;
#X restore 37 256 pd make_sends;
#N canvas 0 51 315 289 make_receives 0;
#X msg 109 122 obj 10 50 r to_mtx_mul;
#X msg 86 146 obj 10 150 r mtx_ramp;
#X obj 63 97 t b b b;
#X obj 63 71 inlet;
#X obj 109 175 outlet make_obj;
#X obj 63 197 outlet done;
#X connect 0 0 4 0;
#X connect 1 0 4 0;
#X connect 2 0 5 0;
#X connect 2 1 1 0;
#X connect 2 2 0 0;
#X connect 3 0 2 0;
#X restore 37 282 pd make_receives;
#N canvas 675 51 504 576 make_connections 0;
#X text 185 124 connect to [mtx_*~];
#X text 185 290 connect from [mtx_*~];
#X obj 35 10 inlet;
#X obj 35 32 v inlets;
#X obj 60 100 + 1;
#X msg 60 289 connect 0 \$1 \$2 0;
#X obj 35 156 v outlets;
#X obj 92 245 +;
#X obj 107 223 + 1;
#X msg 60 123 connect \$1 0 0 \$1;
#X obj 60 200 t f f;
#X obj 60 267 pack;
#X obj 35 54 t f f;
#X obj 35 340 v inlets;
#X obj 53 387 v outlets;
#X obj 35 409 +;
#X obj 35 431 + 1;
#X obj 35 453 t f f;
#X obj 35 475 + 1;
#X msg 105 470 connect \$1 0 0 0;
#X msg 35 523 connect \$1 0 0 \$2;
#X obj 35 362 t f f;
#X obj 67 475 + 1;
#X obj 35 499 pack;
#X obj 35 317 t b b;
#X obj 303 445 outlet connections;
#X obj 35 78 loop;
#X obj 35 179 loop;
#X connect 2 0 3 0;
#X connect 3 0 12 0;
#X connect 4 0 9 0;
#X connect 5 0 25 0;
#X connect 6 0 27 0;
#X connect 7 0 11 1;
#X connect 8 0 7 1;
#X connect 9 0 25 0;
#X connect 10 0 11 0;
#X connect 10 1 7 0;
#X connect 11 0 5 0;
#X connect 12 0 26 0;
#X connect 12 1 8 0;
#X connect 13 0 21 0;
#X connect 14 0 15 1;
#X connect 15 0 16 0;
#X connect 16 0 17 0;
#X connect 17 0 18 0;
#X connect 17 1 19 0;
#X connect 18 0 23 0;
#X connect 19 0 25 0;
#X connect 20 0 25 0;
#X connect 21 0 15 0;
#X connect 21 1 22 0;
#X connect 22 0 23 1;
#X connect 23 0 20 0;
#X connect 24 0 13 0;
#X connect 24 1 14 0;
#X connect 26 0 6 0;
#X connect 26 1 4 0;
#X connect 27 0 24 0;
#X connect 27 1 10 0;
#X restore 37 307 pd make_connections;
#X obj 37 87 t b b;
#X obj 37 159 pack;
#X obj 69 109 v inlets;
#X obj 37 133 v outlets;
#X msg 220 198 obj 100 100 mtx_*~ \$1 \$2 15 ...........................................
;
#X connect 0 0 4 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 3 1 13 0;
#X connect 4 0 9 0;
#X connect 4 1 2 0;
#X connect 5 0 6 0;
#X connect 5 1 1 0;
#X connect 6 0 7 0;
#X connect 6 1 1 0;
#X connect 7 0 8 0;
#X connect 7 1 1 0;
#X connect 8 0 1 0;
#X connect 9 0 12 0;
#X connect 9 1 11 0;
#X connect 10 0 3 0;
#X connect 11 0 10 1;
#X connect 12 0 10 0;
#X connect 13 0 1 0;
#X restore 31 287 pd create_matrix;
#N canvas 25 259 1234 315 matrix 0;
#X obj 100 50 catch~ output0;
#X obj 200 50 catch~ output1;
#X obj 300 50 catch~ output2;
#X obj 400 50 catch~ output3;
#X obj 100 150 send~ input0;
#X obj 200 150 send~ input1;
#X obj 300 150 send~ input2;
#X obj 400 150 send~ input3;
#X obj 500 150 send~ input4;
#X obj 600 150 send~ input5;
#X obj 700 150 send~ input6;
#X obj 800 150 send~ input7;
#X obj 900 150 send~ input8;
#X obj 1000 150 send~ input9;
#X obj 1100 150 send~ input10;
#X obj 1200 150 send~ input11;
#X obj 10 50 r to_mtx_mul;
#X obj 10 150 r mtx_ramp;
#X obj 100 100 mtx_*~ 12 4 15 ...........................................
;
#X connect 0 0 18 1;
#X connect 1 0 18 2;
#X connect 2 0 18 3;
#X connect 3 0 18 4;
#X connect 16 0 18 0;
#X connect 17 0 18 5;
#X connect 18 0 4 0;
#X connect 18 1 5 0;
#X connect 18 2 6 0;
#X connect 18 3 7 0;
#X connect 18 4 8 0;
#X connect 18 5 9 0;
#X connect 18 6 10 0;
#X connect 18 7 11 0;
#X connect 18 8 12 0;
#X connect 18 9 13 0;
#X connect 18 10 14 0;
#X connect 18 11 15 0;
#X restore 31 312 pd matrix;
#X msg 31 264 bang;
#X text 65 265 <- create new matrix;
#X text 41 18 Module abstraction arguments:;
#X text 40 35 1st: module number \, starting from 0;
#X text 40 52 2nd: number of inlets (output shift registers);
#X text 40 117 4th: number of outlets (input shift registers);
#X obj 286 261 pow_sine~ 1 3 6 1 1;
#X obj 286 283 adc_dac~ 2 3 9 2 2;
#X obj 286 239 var_shapes~ 0 6 0 1 0;
#X text 40 71 3rd: number of first inlet (output shift register) in
the matrix ([mtx_*~] outlet) \, starting from 0 (sum of args 2 and
3 of previous abstraction in the chain);
#X text 40 137 5th: number of first outlet (input shift registers)
in the matrix ([mtx_*~] inlet) \, starting from 0 (sum of args 4 and
5 of previous abstraction in the chain);
#X connect 0 0 1 0;
#X connect 2 0 13 0;
#X connect 5 0 3 0;
#X connect 11 0 12 0;
#X connect 13 0 11 0;
#X restore 45 334 pd audio-engine;
#X text 44 156 check serial devices;
#X floatatom 97 205 5 0 0 0 - - -, f 5;
#X text 95 190 open serial port;
#X obj 44 8 cnv 15 80 30 empty empty empty 20 12 0 14 -228485 -66577
0;
#N canvas 144 63 508 394 readme 0;
#X text 36 10 Things you need to check in order for this patch to work
properly along with its Arduino sketch.;
#X text 36 271 In case the Teensy goes crazy and starts reading connections
that are not there \, there is a "zero-previous_states" subpatch in
the comparison-tables subpatch so you can reset them along with [mtx].
;
#X text 36 50 In the [pd receivedData] subpatch \, make sure the [v
outlets] and [v inlets] variables contain the correct number of outlets
and inlets of [mtx_*~]. Check the [pd tables] subpatch and make sure
the tables contain the data dectribed in [pd receivedData] and that
they have the appropriate size ("previous_states\$1" tables must have
the size of the number of inlets of [mtx_*~] and they must be as many
as the outlets).;
#X text 37 163 These two variables are also used in [pd create_matrix]
inside [pd audio-engine] \, to create the correct [mtx_*~] object along
with the right [throw~]s and [send~]s. If you change your modules \,
and your inlet and outlet variables \, you'll need to create a new
matrix. Just hit [bang( and it will be created automatically;
#X restore 51 15 pd readme;
#X text 148 211 open device by name;
#X symbolatom 150 229 14 0 0 0 - - -, f 14;
#X obj 42 58 declare -lib /usr/lib/pd/extra/iemmatrix -lib /usr/lib/pd/extra/zexy
-path ./generic_abstractions -path ./modules;
#X msg 45 173 devices;
#X msg 203 262 close;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 3 1;
#X connect 5 0 0 1;
#X connect 10 0 0 2;
#X connect 12 0 0 0;
#X connect 13 0 0 3;
