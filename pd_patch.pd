#N canvas 384 174 498 453 10;
#X declare -lib /usr/lib/pd/extra/iemmatrix -lib /usr/lib/pd/extra/zexy
-path ./generic_abstractions -path ./modules -path ./modules/module_instances
;
#X declare -path ../generic_abstractions;
#X declare -path ../generic_abstractions;
#X declare -path ../../generic_abstractions;
#X declare -path ../generic_abstractions -path ./module_instances;
#X text 82 212 close serial port;
#X text 44 116 check serial devices;
#X floatatom 57 166 5 0 0 0 - - -, f 5;
#X text 55 151 open serial port;
#X obj 44 8 cnv 15 80 30 empty empty empty 20 12 0 14 -228485 -66577
0;
#N canvas 141 61 508 394 readme 0;
#X text 36 10 Things you need to check in order for this patch to work
properly along with its Arduino sketch.;
#X text 36 271 In case the Teensy goes crazy and starts reading connections
that are not there \, there is a "zero-previous_states" subpatch in
the comparison-tables subpatch so you can reset them along with [mtx].
;
#X text 36 172 These two variables are also used in [pd create_matrix]
inside [pd matrix_et_al] \, to create the correct [mtx_*~] object along
with the right [throw~]s and [send~]s. If you change your modules \,
and your inlet and outlet variables \, you'll need to create a new
matrix. Just hit [bang( and it will be created automatically;
#X text 36 50 In the [pd comparison-tables] subpatch \, make sure the
[v outlets] and [v inlets] variables contain the correct number of
outlets and inlets of [mtx_*~]. Check the [pd tables] subpatch and
make sure the tables contain the data dectribed in their parent subpatch
and that they have the appropriate size ("previous_states\$1" tables
must have the size of the number of inlets of [mtx_*~] and they must
be as many as the outlets).;
#X restore 51 15 pd readme;
#X text 68 180 open device by name;
#X symbolatom 70 198 14 0 0 0 - - -, f 14;
#X msg 45 133 devices;
#X msg 83 229 close;
#X obj 220 183 r pd;
#X obj 220 205 route dsp;
#X text 293 206 control the DSP LED;
#N canvas 369 158 743 515 receive_teensy_data 0;
#X obj 27 220 select 192;
#X text 102 216 This is 0xc0 in the Arduino code which denotes the
beginning of the data stream;
#X obj 27 80 inlet;
#X obj 27 102 route devices float close symbol;
#X msg 27 170 devices;
#X msg 82 148 open \$1;
#X msg 137 126 close;
#X msg 192 126 devicename \$1;
#X obj 27 197 comport 0 115200;
#X obj 264 329 spigot;
#X obj 126 402 spigot;
#X obj 264 374 repack;
#X obj 303 352 tabread num_of_pots;
#X msg 303 307 1;
#X msg 337 312 0;
#X obj 287 465 s;
#X msg 305 441 symbol module\$1;
#X obj 94 339 t b f;
#X obj 264 420 t b l b;
#X obj 94 312 t f f;
#X obj 126 424 t b b f f;
#X msg 165 352 0;
#X msg 197 364 1;
#X obj 461 331 spigot;
#X obj 528 374 t l b;
#X obj 500 310 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X text 509 331 debug input;
#X obj 461 353 route bang;
#X obj 27 242 t b b b;
#X obj 264 396 spigot;
#X msg 194 259 0;
#X msg 27 264 1;
#X obj 27 286 t f f;
#X obj 165 381 f;
#X text 258 94 anything not matching [route]'s args will be input to
[comport] intact (e.g. a [print \$1d( message);
#X obj 194 281 t f f f;
#X obj 528 396 print list;
#X connect 0 0 28 0;
#X connect 0 1 19 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 3 1 5 0;
#X connect 3 2 6 0;
#X connect 3 3 7 0;
#X connect 3 4 8 0;
#X connect 4 0 8 0;
#X connect 5 0 8 0;
#X connect 6 0 8 0;
#X connect 7 0 8 0;
#X connect 8 0 0 0;
#X connect 9 0 11 0;
#X connect 10 0 20 0;
#X connect 11 0 29 0;
#X connect 11 0 23 0;
#X connect 12 0 11 1;
#X connect 13 0 9 1;
#X connect 14 0 9 1;
#X connect 16 0 15 1;
#X connect 17 0 33 0;
#X connect 17 1 10 0;
#X connect 18 0 22 0;
#X connect 18 1 15 0;
#X connect 18 2 14 0;
#X connect 19 0 17 0;
#X connect 19 1 9 0;
#X connect 20 0 21 0;
#X connect 20 1 13 0;
#X connect 20 2 12 0;
#X connect 20 3 16 0;
#X connect 21 0 33 0;
#X connect 22 0 33 1;
#X connect 23 0 27 0;
#X connect 24 0 36 0;
#X connect 24 1 25 0;
#X connect 25 0 23 1;
#X connect 27 1 24 0;
#X connect 28 0 31 0;
#X connect 28 1 11 0;
#X connect 28 2 30 0;
#X connect 29 0 18 0;
#X connect 30 0 35 0;
#X connect 31 0 32 0;
#X connect 32 0 33 0;
#X connect 32 1 29 1;
#X connect 33 0 10 1;
#X connect 35 0 33 0;
#X connect 35 1 29 1;
#X connect 35 2 9 1;
#X restore 45 269 pd receive_teensy_data;
#X msg 220 227 print \$1d;
#N canvas 138 106 1015 597 comparison-tables 0;
#X floatatom 560 374 5 0 0 2 index - -, f 5;
#X floatatom 507 374 5 0 0 2 value - -, f 5;
#X obj 455 33 loadbang;
#X obj 566 141 v num_of_modules;
#X floatatom 534 26 5 0 0 2 num_of_modules - -, f 5;
#X msg 626 369 store;
#X msg 630 392 read;
#X symbolatom 455 343 16 0 0 2 set_table - -, f 16;
#X msg 629 413 clear;
#X msg 534 97 3;
#X obj 455 362 t s b;
#N canvas 375 169 346 196 create-tables 0;
#X obj 195 109 s pd-tables;
#X obj 37 21 inlet;
#N canvas 200 51 437 366 pins_and_inlets_tabs 0;
#X obj 68 83 t f f;
#X obj 68 151 pack;
#X obj 100 105 * 20;
#X obj 100 127 + 10;
#X obj 43 18 inlet;
#X obj 43 326 outlet;
#X obj 149 326 outlet;
#X msg 129 215 obj 20 \$1 table all_inlets_tab;
#X msg 108 235 obj 20 \$1 table num_of_switches;
#X msg 88 255 obj 20 \$1 table switch_pins;
#X msg 68 275 obj 20 \$1 table input_pins;
#X obj 43 61 loop;
#X msg 43 39 5;
#X obj 68 173 route 0 1 2 3 4;
#X msg 149 194 obj 20 \$1 table num_of_pots;
#X connect 0 0 1 0;
#X connect 0 1 2 0;
#X connect 1 0 13 0;
#X connect 2 0 3 0;
#X connect 3 0 1 1;
#X connect 4 0 12 0;
#X connect 7 0 6 0;
#X connect 8 0 6 0;
#X connect 9 0 6 0;
#X connect 10 0 6 0;
#X connect 11 0 5 0;
#X connect 11 1 0 0;
#X connect 12 0 11 0;
#X connect 13 0 10 0;
#X connect 13 1 9 0;
#X connect 13 2 8 0;
#X connect 13 3 7 0;
#X connect 13 4 14 0;
#X connect 14 0 6 0;
#X restore 37 68 pd pins_and_inlets_tabs;
#N canvas 0 51 347 255 states_tabs 0;
#X obj 73 101 * 20;
#X obj 73 123 + 10;
#X obj 73 145 pack;
#X msg 73 168 obj 300 \$1 table previous_states\$2;
#X obj 48 36 v outlets;
#X obj 73 78 t f f;
#X obj 48 14 inlet;
#X obj 48 218 outlet;
#X obj 73 190 outlet;
#X obj 48 58 loop;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 8 0;
#X connect 4 0 9 0;
#X connect 5 0 0 0;
#X connect 5 1 2 1;
#X connect 6 0 4 0;
#X connect 9 0 7 0;
#X connect 9 1 5 0;
#X restore 37 92 pd states_tabs;
#N canvas 244 87 629 316 resize 0;
#X obj 40 126 v outlets;
#X obj 90 149 v inlets;
#X obj 40 21 inlet;
#X obj 288 16 inlet;
#X obj 40 202 outlet;
#X obj 288 38 t b b;
#X obj 320 59 v num_of_modules;
#X obj 40 65 loop;
#X obj 295 259 array size;
#X obj 295 82 swap;
#X msg 422 174 symbol all_inlets_tab;
#X msg 422 197 symbol num_of_switches;
#X msg 423 220 symbol switch_pins;
#X msg 423 242 symbol input_pins;
#X msg 102 171 symbol previous_states\$1;
#X obj 65 171 swap;
#X obj 40 148 loop;
#X msg 40 43 5;
#X obj 352 128 sel 0 1 2 3 4;
#X msg 422 151 symbol num_of_pots;
#X obj 320 105 t f f;
#X obj 320 173 == 4;
#X obj 320 195 * 2;
#X obj 295 222 +;
#X connect 0 0 16 0;
#X connect 1 0 15 1;
#X connect 2 0 17 0;
#X connect 3 0 5 0;
#X connect 5 0 1 0;
#X connect 5 1 6 0;
#X connect 6 0 9 1;
#X connect 7 0 0 0;
#X connect 7 1 9 0;
#X connect 9 0 23 0;
#X connect 9 1 20 0;
#X connect 10 0 8 1;
#X connect 11 0 8 1;
#X connect 12 0 8 1;
#X connect 13 0 8 1;
#X connect 14 0 8 1;
#X connect 15 0 8 0;
#X connect 15 1 14 0;
#X connect 16 0 4 0;
#X connect 16 1 15 0;
#X connect 17 0 7 0;
#X connect 18 0 13 0;
#X connect 18 1 12 0;
#X connect 18 2 11 0;
#X connect 18 3 10 0;
#X connect 18 4 19 0;
#X connect 19 0 8 1;
#X connect 20 0 21 0;
#X connect 20 1 18 0;
#X connect 21 0 22 0;
#X connect 22 0 23 1;
#X connect 23 0 8 0;
#X restore 37 116 pd resize;
#X obj 37 138 outlet;
#X obj 37 43 t b b b;
#X msg 215 60 clear;
#X connect 1 0 6 0;
#X connect 2 0 3 0;
#X connect 2 1 0 0;
#X connect 3 0 4 0;
#X connect 3 1 0 0;
#X connect 4 0 5 0;
#X connect 6 0 2 0;
#X connect 6 1 4 1;
#X connect 6 2 7 0;
#X connect 7 0 0 0;
#X restore 455 292 pd create-tables;
#X obj 534 45 t b f;
#X msg 566 66 set \$1;
#X msg 548 190 4;
#X obj 548 212 v inlets;
#X obj 510 243 v outlets;
#X text 579 243 number of outlets and inlets of [mtx_*~];
#X obj 455 173 t b b b;
#X text 9 65 switch_pins table should store the pin the first switch
is attached to on each module \, starting from 0;
#X text 9 101 num_of_switches table should store the number of switches
on each module;
#X msg 619 348 manual;
#X msg 613 326 automatic;
#X text 682 326 index;
#X text 668 349 index;
#X text 670 369 values;
#X text 667 392 values;
#X text 672 413 [textfile];
#N canvas 61 63 1060 544 set-values-to-tables 0;
#X obj 21 366 tabwrite;
#X obj 461 116 t b b;
#X obj 443 207 f;
#X obj 473 208 + 1;
#X msg 461 185 0;
#X obj 39 144 t f b;
#X obj 443 161 spigot;
#X msg 482 139 1;
#X msg 515 115 0;
#X obj 21 4 inlet which_table;
#X obj 39 110 inlet value;
#X obj 74 338 inlet index;
#X obj 21 53 list prepend set;
#X obj 21 75 list trim;
#X obj 569 289 textfile;
#X msg 677 116 clear;
#X msg 535 209 write ./data/tables.txt;
#X msg 545 187 add \$1;
#X msg 589 261 rewind;
#X msg 609 239 read ./data/tables.txt;
#X obj 601 482 s;
#X msg 629 184 1;
#X obj 581 374 spigot;
#X msg 654 306 0;
#X msg 801 240 symbol write;
#X msg 601 442 \$2 ./data/\$1.txt;
#X obj 601 419 pack s s;
#X obj 569 160 t b b b b;
#X obj 569 116 t b b;
#X obj 623 116 t b b;
#X msg 802 216 symbol read;
#X text 633 276 store table names to a text file to be able to call
them automatically;
#X obj 569 311 t b a;
#X obj 633 465 symbol;
#X obj 601 396 t a a;
#X obj 461 71 inlet features;
#X obj 461 94 route automatic manual store read clear;
#X obj 443 349 t f f;
#X obj 21 26 t s s b b s;
#X obj 35 164 cnv 15 160 170 empty empty empty 20 12 0 14 -203904 -66577
0;
#X obj 57 171 sel num_of_pots;
#X msg 57 193 2;
#X msg 159 198 1;
#X obj 39 215 *;
#X obj 75 222 v num_of_modules;
#X obj 57 266 * 0.5;
#X obj 57 288 + 0.5;
#X obj 57 244 <;
#X obj 39 310 *;
#X text 206 181 this whole thing is here so;
#X text 208 194 we can store the num_of_pots;
#X text 207 207 elements without needing to;
#X text 207 220 calculate the double number;
#X text 212 232 of pots;
#X connect 1 0 4 0;
#X connect 1 1 7 0;
#X connect 2 0 3 0;
#X connect 2 0 37 0;
#X connect 3 0 2 1;
#X connect 4 0 2 1;
#X connect 5 0 43 0;
#X connect 5 1 6 0;
#X connect 6 0 2 0;
#X connect 7 0 6 1;
#X connect 8 0 6 1;
#X connect 9 0 38 0;
#X connect 10 0 5 0;
#X connect 11 0 0 1;
#X connect 12 0 13 0;
#X connect 13 0 0 0;
#X connect 14 0 32 0;
#X connect 14 1 23 0;
#X connect 15 0 14 0;
#X connect 16 0 14 0;
#X connect 17 0 14 0;
#X connect 18 0 14 0;
#X connect 19 0 14 0;
#X connect 21 0 22 1;
#X connect 22 0 14 0;
#X connect 23 0 22 1;
#X connect 24 0 26 1;
#X connect 25 0 20 0;
#X connect 26 0 25 0;
#X connect 27 0 14 0;
#X connect 27 1 18 0;
#X connect 27 2 19 0;
#X connect 27 3 21 0;
#X connect 28 0 27 0;
#X connect 28 1 24 0;
#X connect 29 0 27 0;
#X connect 29 1 30 0;
#X connect 30 0 26 1;
#X connect 32 0 22 0;
#X connect 32 1 34 0;
#X connect 33 0 20 1;
#X connect 34 0 26 0;
#X connect 34 1 33 0;
#X connect 35 0 36 0;
#X connect 36 0 1 0;
#X connect 36 1 8 0;
#X connect 36 2 28 0;
#X connect 36 3 29 0;
#X connect 36 4 15 0;
#X connect 37 0 0 1;
#X connect 37 1 47 0;
#X connect 38 0 12 0;
#X connect 38 1 40 0;
#X connect 38 2 44 0;
#X connect 38 3 16 0;
#X connect 38 4 17 0;
#X connect 40 0 41 0;
#X connect 40 1 42 0;
#X connect 41 0 43 1;
#X connect 42 0 43 1;
#X connect 43 0 48 0;
#X connect 44 0 47 1;
#X connect 45 0 46 0;
#X connect 46 0 48 1;
#X connect 47 0 45 0;
#X restore 455 393 pd set-values-to-tables;
#X msg 466 55 bang;
#N canvas 280 51 513 492 tables 0;
#X obj 20 10 table input_pins;
#X obj 20 30 table switch_pins;
#X obj 20 50 table num_of_switches;
#X obj 20 70 table all_inlets_tab;
#X obj 20 90 table num_of_pots;
#X obj 300 10 table previous_states0;
#X obj 300 30 table previous_states1;
#X obj 300 50 table previous_states2;
#X obj 300 70 table previous_states3;
#X obj 300 90 table previous_states4;
#X obj 300 110 table previous_states5;
#X obj 300 130 table previous_states6;
#X obj 300 150 table previous_states7;
#X obj 300 170 table previous_states8;
#X obj 300 190 table previous_states9;
#X obj 300 210 table previous_states10;
#X obj 300 230 table previous_states11;
#X obj 300 250 table previous_states12;
#X restore 10 532 pd tables;
#N canvas 567 235 311 279 zero-previous_states 0;
#X obj 75 15 inlet;
#X obj 75 37 v outlets;
#X obj 75 81 until;
#X obj 75 124 f;
#X obj 105 125 + 1;
#X msg 93 103 0;
#X obj 75 146 t b f;
#X msg 107 193 symbol previous_states\$1;
#X msg 75 168 const 0;
#X obj 75 210 s;
#X obj 75 59 t f b b;
#X obj 121 81 s matrix;
#X connect 0 0 1 0;
#X connect 1 0 10 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 3 1;
#X connect 5 0 3 1;
#X connect 6 0 8 0;
#X connect 6 1 7 0;
#X connect 7 0 9 1;
#X connect 8 0 9 0;
#X connect 10 0 2 0;
#X connect 10 1 5 0;
#X connect 10 2 11 0;
#X restore 455 443 pd zero-previous_states;
#X msg 455 420 bang;
#X obj 478 221 t f f;
#X text 589 266 goes into [pd compare-value] inside [pd set-connections]
;
#X obj 534 163 s num_modules;
#X text 632 159 goes into [pd num-of-loop-repetitions] inside [pd set-connections]
and in [pd get-switches];
#X obj 478 266 s num_outlets;
#X text 10 26 input_pins table should store the number of input pins
used on each module;
#X text 9 386 previous_states\$1 tables store the states of connections.
\$1 is the outlet number of [mtx_*~] and the table's size is the number
of inlets of [mtx_*~] so you get a unique value for all possible connections.
these tables are used in the [pd set-connections] \, where their values
are compared to incoming values. if they are the same \, set-connection
won't output anything \, if they are different \, [pd set-connections]
will output a matrix message of the form "element \$1 \$2 \$3" and
it will store the new connection to the corresponding previous_states\$1
table \, at the corresponding index;
#X msg 478 199 13;
#X obj 455 80 t b b;
#X obj 534 119 t f f;
#X text 9 291 num_of_pots table stores double the number of potentiometers
on each module (double cause the pot values are being split in two
in order not to conflict with 0xc0 which denotes the beginning of the
data stream). the pre-last element of the table should be 4 and the
last 3 (these are the bytes for the connections and the switches);
#X text 9 139 all_inlets_tab table stores the number of the first inlet
of each module in the matrix. this happens automatically at load time.
the reason for this is that we need to define a name for some [receive]s
in the module abstractions \, in the form [r \$3-incoming_amp_freq]
in the oscillator (and probably filter) modules \, in case a module
connects to an inlet of the oscillator \, not the first one. since
only the first inlet is defined in the abstraction arguments \, and
[receive] is not so flexible in naming it \, we need to know these
numbers \, to define a proper name for these [receive]s. check oscillator
modules for further info;
#X connect 0 0 28 2;
#X connect 1 0 28 1;
#X connect 2 0 41 0;
#X connect 4 0 12 0;
#X connect 5 0 28 3;
#X connect 6 0 28 3;
#X connect 7 0 10 0;
#X connect 8 0 28 3;
#X connect 9 0 42 0;
#X connect 10 0 28 0;
#X connect 10 1 22 0;
#X connect 11 0 6 0;
#X connect 12 0 9 0;
#X connect 12 1 13 0;
#X connect 13 0 9 0;
#X connect 14 0 15 0;
#X connect 18 0 11 0;
#X connect 18 1 40 0;
#X connect 18 2 14 0;
#X connect 21 0 28 3;
#X connect 22 0 28 3;
#X connect 29 0 41 0;
#X connect 32 0 31 0;
#X connect 33 0 37 0;
#X connect 33 1 16 0;
#X connect 40 0 33 0;
#X connect 41 0 18 0;
#X connect 41 1 9 0;
#X connect 42 0 35 0;
#X connect 42 1 3 0;
#X restore 45 291 pd comparison-tables;
#N canvas 285 208 775 537 get-switches 0;
#X obj 21 217 until;
#X obj 53 379 f;
#X obj 53 404 &;
#X obj 53 426 == 0;
#X obj 21 43 unpack f f f;
#X obj 290 198 tabread switch_pins;
#X obj 313 175 tabread num_of_switches;
#X obj 21 82 +;
#X obj 61 65 * 128;
#X text 115 39 incoming bytes are input byte and input chip #;
#X obj 21 451 pack f f f;
#X msg 21 473 \$3 \$1 \$2;
#X obj 267 124 t f f f;
#X obj 89 312 swap 2;
#X obj 89 334 pow;
#X obj 85 379 * 2;
#X obj 21 192 f;
#X obj 290 222 t f f;
#X obj 21 260 f;
#X obj 51 261 + 1;
#X obj 21 303 t f b;
#X text 76 262 start from # of pin the first switch is attached to
;
#X text 322 145 loop for as many times as the number of switches attached
to the current chip;
#X text 87 473 spit input chip # with switch index and value;
#N canvas 760 223 245 249 switch-changed1 0;
#X obj 125 88 f;
#X obj 65 62 t f f f b;
#X obj 85 105 !=;
#X obj 139 187 spigot;
#X obj 85 127 t f f;
#X obj 65 39 inlet;
#X obj 139 209 outlet;
#X obj 85 209 outlet;
#X connect 0 0 2 1;
#X connect 1 0 3 0;
#X connect 1 1 2 0;
#X connect 1 2 0 1;
#X connect 1 3 0 0;
#X connect 2 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 4 1 3 1;
#X connect 5 0 1 0;
#X restore 144 60 pd switch-changed1;
#N canvas 301 109 568 391 switch-changed2 0;
#X obj 34 69 inlet;
#X obj 34 91 t b f;
#X obj 100 111 > 0;
#X obj 34 128 spigot;
#X obj 209 108 t f f f b;
#X obj 269 133 f;
#X obj 229 150 !=;
#X obj 209 269 spigot;
#X obj 209 291 f;
#X obj 209 313 outlet;
#X obj 229 172 t f f;
#X obj 34 216 spigot;
#X obj 229 199 == 0;
#X text 99 68 if the other value has changed open the [spigot] below
;
#X text 80 222 if this value has changed you don't need to bang it
\, if it hasn't \, you should bang it if the other has changed;
#X obj 100 88 inlet changed;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 4 0;
#X connect 2 0 3 1;
#X connect 3 0 11 0;
#X connect 4 0 7 0;
#X connect 4 1 6 0;
#X connect 4 2 5 1;
#X connect 4 3 5 0;
#X connect 5 0 6 1;
#X connect 6 0 10 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 1 7 1;
#X connect 11 0 8 0;
#X connect 12 0 11 1;
#X connect 15 0 2 0;
#X restore 21 104 pd switch-changed2;
#X obj 39 239 f;
#X obj 71 357 f;
#X obj 21 169 t b b f b;
#X text 115 347 values read from tables need to be stored in a variable
cause they won't be output if they don't change and that will cause
an overflow;
#X obj 267 99 moses 255;
#X obj 327 55 r num_modules;
#X obj 327 77 + 1;
#X text 336 99 exclude non-existent table indices;
#X obj 21 494 s switches;
#X obj 21 11 r module4;
#X text 89 8 this name is due to the dynamic naming of [send] in the
teensy_data subpatch (the number is num_of_modules + 1);
#X connect 0 0 18 0;
#X connect 1 0 15 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 10 1;
#X connect 4 0 7 0;
#X connect 4 1 8 0;
#X connect 4 2 24 0;
#X connect 5 0 17 0;
#X connect 6 0 16 1;
#X connect 7 0 25 0;
#X connect 8 0 7 1;
#X connect 10 0 11 0;
#X connect 11 0 34 0;
#X connect 12 0 10 2;
#X connect 12 1 5 0;
#X connect 12 2 6 0;
#X connect 13 0 14 0;
#X connect 13 1 14 1;
#X connect 14 0 27 1;
#X connect 15 0 1 1;
#X connect 16 0 0 0;
#X connect 17 0 26 1;
#X connect 17 1 13 0;
#X connect 18 0 19 0;
#X connect 18 0 20 0;
#X connect 19 0 18 1;
#X connect 20 0 10 0;
#X connect 20 1 1 0;
#X connect 24 0 25 1;
#X connect 24 1 30 0;
#X connect 25 0 28 0;
#X connect 26 0 18 1;
#X connect 27 0 1 1;
#X connect 28 0 16 0;
#X connect 28 1 26 0;
#X connect 28 2 2 1;
#X connect 28 3 27 0;
#X connect 30 0 12 0;
#X connect 31 0 32 0;
#X connect 32 0 30 1;
#X connect 35 0 4 0;
#X restore 45 337 pd get-switches;
#N canvas 579 51 611 515 set-connections 0;
#X obj 17 226 until;
#X obj 17 272 f;
#X obj 17 356 &;
#X obj 17 378 == 0;
#X msg 17 433 element \$3 \$2 \$1;
#X obj 17 128 +;
#X obj 35 105 * 128;
#X msg 35 249 1;
#X obj 49 272 * 2;
#X text 22 322 bitwise AND with 1 \, 2 \, 4 \, 8 \, 16 \, 32... and
check for inequality with zero;
#X obj 17 38 unpack f f f f;
#X text 125 45 incoming bytes refer to input byte \, output pin # and
input chip #;
#X obj 17 202 f;
#X obj 17 179 t b b f b;
#X obj 17 297 t f b;
#N canvas 430 204 526 362 banana-changed2 0;
#X obj 34 66 inlet;
#X obj 34 88 t b f;
#X obj 90 65 > 0;
#X obj 34 128 spigot;
#X obj 149 105 t f f f b;
#X obj 209 130 f;
#X obj 166 147 !=;
#X obj 149 269 spigot;
#X obj 149 291 f;
#X obj 149 313 outlet;
#X obj 166 169 t f f;
#X obj 34 216 spigot;
#X obj 73 194 == 0;
#X text 116 60 if the other value has changed open the [spigot] below
;
#X text 84 212 if this value has changed you don't need to bang it
\, if it hasn't \, you should bang it if the other has changed;
#X obj 90 43 inlet;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 4 0;
#X connect 2 0 3 1;
#X connect 3 0 11 0;
#X connect 4 0 7 0;
#X connect 4 1 6 0;
#X connect 4 2 5 1;
#X connect 4 3 5 0;
#X connect 5 0 6 1;
#X connect 6 0 10 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 1 7 1;
#X connect 11 0 8 0;
#X connect 12 0 11 1;
#X connect 15 0 2 0;
#X restore 17 155 pd banana-changed2;
#X text 61 205 run the loop for as many times as the number of pins
used of current input chip;
#N canvas 11 103 602 518 compare-value 0;
#X obj 52 308 t f f;
#X obj 91 331 !=;
#X obj 52 359 spigot;
#X obj 52 381 t f f;
#X msg 245 144 set previous_states\$1;
#X obj 109 304 tabread;
#X obj 277 398 tabwrite;
#X obj 245 166 t a a;
#X obj 85 189 f;
#X obj 115 189 + 1;
#X msg 103 166 0;
#X obj 85 234 +;
#X text 342 397 store altered state;
#X obj 85 422 + 1;
#X text 146 421 + 1 cause [mtx_*~] starts counting from 1;
#X obj 245 121 t f f;
#X obj 119 422 + 1;
#X obj 85 256 t f f f;
#X text 165 303 compare stored state of connection;
#X obj 305 74 + 1;
#X obj 52 83 inlet value;
#X obj 85 113 inlet bang_until;
#X obj 103 141 inlet bang_once;
#X obj 245 25 inlet which_outlet;
#X obj 52 450 pack f f f;
#X obj 52 472 outlet;
#X obj 386 217 inlet inlet_offset;
#X text 315 95 exclude values of non-existent tables;
#X obj 245 96 moses 255;
#X obj 305 52 r num_outlets;
#X connect 0 0 2 0;
#X connect 0 1 1 0;
#X connect 1 0 2 1;
#X connect 2 0 3 0;
#X connect 3 0 24 0;
#X connect 3 1 6 0;
#X connect 4 0 7 0;
#X connect 5 0 1 1;
#X connect 7 0 5 0;
#X connect 7 1 6 0;
#X connect 8 0 9 0;
#X connect 8 0 11 0;
#X connect 9 0 8 1;
#X connect 10 0 8 1;
#X connect 11 0 17 0;
#X connect 13 0 24 1;
#X connect 15 0 4 0;
#X connect 15 1 16 0;
#X connect 16 0 24 2;
#X connect 17 0 13 0;
#X connect 17 1 5 0;
#X connect 17 2 6 1;
#X connect 19 0 28 1;
#X connect 20 0 0 0;
#X connect 21 0 8 0;
#X connect 22 0 10 0;
#X connect 23 0 28 0;
#X connect 24 0 25 0;
#X connect 26 0 11 1;
#X connect 28 0 15 0;
#X connect 29 0 19 0;
#X restore 17 404 pd compare-value;
#N canvas 225 158 699 553 num-of-loop-repetitions 0;
#X obj 214 317 until;
#X obj 214 361 f;
#X obj 244 361 + 1;
#X msg 232 339 0;
#X obj 214 384 tabread input_pins;
#X obj 214 428 +;
#X obj 244 428 f;
#X msg 232 406 0;
#X obj 214 295 t f b b;
#X obj 168 262 moses 1;
#X obj 77 136 tabread input_pins;
#X obj 45 113 t f f;
#X text 53 207 accumulate used input pins of previous chips to set
correct inlet number offset;
#N canvas 265 391 172 238 banana-changed1 0;
#X obj 105 88 f;
#X obj 45 62 t f f f b;
#X obj 65 105 !=;
#X obj 58 157 spigot;
#X obj 65 127 t f f;
#X obj 45 39 inlet;
#X obj 58 179 outlet;
#X obj 8 179 outlet;
#X connect 0 0 2 1;
#X connect 1 0 3 0;
#X connect 1 1 2 0;
#X connect 1 2 0 1;
#X connect 1 3 0 0;
#X connect 2 0 4 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 4 1 3 1;
#X connect 5 0 1 0;
#X restore 45 239 pd banana-changed1;
#X obj 105 66 + 1;
#X obj 45 18 inlet input_chip;
#X obj 77 158 outlet loop_times;
#X obj 168 478 outlet inlet_offset;
#X obj 45 263 outlet changed;
#X text 116 86 exclude non-existent table indices;
#X obj 45 88 moses 255;
#X obj 105 44 r num_modules;
#X text 222 260 a 0 won't make [until] run a loop so send it to [+
] in [pd compare-value] explicitly;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 4 0;
#X connect 2 0 1 1;
#X connect 3 0 1 1;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 5 0 17 0;
#X connect 6 0 5 1;
#X connect 7 0 5 1;
#X connect 8 0 0 0;
#X connect 8 1 3 0;
#X connect 8 2 7 0;
#X connect 9 0 17 0;
#X connect 9 1 8 0;
#X connect 10 0 16 0;
#X connect 11 0 13 0;
#X connect 11 1 10 0;
#X connect 13 0 18 0;
#X connect 13 1 9 0;
#X connect 14 0 20 1;
#X connect 15 0 20 0;
#X connect 20 0 11 0;
#X connect 21 0 14 0;
#X restore 140 133 pd num-of-loop-repetitions;
#X obj 17 60 t f b;
#X obj 49 82 s toComport;
#X obj 17 13 r module3;
#X text 89 7 this name is due to the dynamic naming of [send] in the
teensy_data subpatch (the number is num_of_modules);
#X obj 17 458 s matrix_msg;
#X connect 0 0 1 0;
#X connect 1 0 8 0;
#X connect 1 0 14 0;
#X connect 2 0 3 0;
#X connect 3 0 17 0;
#X connect 4 0 23 0;
#X connect 5 0 15 0;
#X connect 6 0 5 1;
#X connect 7 0 1 1;
#X connect 8 0 1 1;
#X connect 10 0 19 0;
#X connect 10 1 6 0;
#X connect 10 2 17 3;
#X connect 10 3 18 0;
#X connect 12 0 0 0;
#X connect 13 0 12 0;
#X connect 13 1 7 0;
#X connect 13 2 2 1;
#X connect 13 3 17 2;
#X connect 14 0 2 0;
#X connect 14 1 17 1;
#X connect 15 0 13 0;
#X connect 17 0 4 0;
#X connect 18 0 15 1;
#X connect 18 1 12 1;
#X connect 18 2 17 4;
#X connect 19 0 5 0;
#X connect 19 1 20 0;
#X connect 21 0 10 0;
#X restore 45 314 pd set-connections;
#X obj 42 58 declare -lib /usr/lib/pd/extra/iemmatrix -lib /usr/lib/pd/extra/zexy
-path ./generic_abstractions -path ./modules -path ./modules/module_instances
;
#N canvas 486 134 822 376 receive_and_collect_matrix_msg 0;
#X obj 349 226 del;
#X obj 390 209 t f f;
#X obj 390 187 spigot;
#X obj 349 114 t f f;
#X text 317 39 when patching is deactivated \, send potentiometer values
to control ramp time for [mtx_*~];
#X obj 349 137 sel 1;
#X obj 317 91 t f f;
#X obj 271 68 t f f;
#X obj 317 69 r patchUpdate;
#X obj 390 164 r ramp;
#X msg 349 248 15;
#X text 378 242 when patching is reactivated \, delay a bang with the
potentiometer value to set [mtx_*~] back to 15ms;
#X obj 429 131 == 0;
#N canvas 145 51 1050 403 whole-matrix-and-data-diffusion 0;
#X obj 13 28 inlet;
#X text 77 266 matrix MUST have same dimensions as [mtx_*~];
#X obj 462 71 list split 2;
#X obj 502 96 unpack;
#X text 555 71 get inlet number and connection state;
#X obj 124 328 mtx_print;
#X obj 124 306 spigot;
#X obj 163 287 tgl 15 0 empty empty debug 17 7 0 10 -262144 -1 -1 0
1;
#X text 19 232 constantly updated matrix that is output only when the
patching update is being REactivated;
#X obj 53 82 inlet;
#X text 104 106 bang matrix when patching update is reactivated;
#X obj 462 240 list split 1;
#X obj 541 119 t f f;
#X obj 13 54 t a a;
#X obj 53 105 sel 1;
#X text 555 239 get outlet number;
#X text 553 90 and send connection state to corresponding "module"
to control [switch~];
#X text 545 257 send connection state to corresponding subpatch of
corresponding "module" to turn a control signal on or off;
#X obj 85 149 s reactivate;
#X text 104 129 and bang subpatches of nodes to update on-off states
;
#X obj 53 178 r matrix;
#X obj 502 294 s inlet_states;
#X obj 502 272 pack;
#X obj 502 158 s outlet_states;
#X obj 502 136 pack;
#X text 612 159 states of modules outlets connections (matrix's inlets)
;
#X text 607 296 states of modules inlets connections (matrix's outlets)
;
#X obj 53 127 t b b;
#X obj 13 328 outlet;
#X obj 13 289 t a a;
#X obj 53 203 mtx_zeros 13 4;
#X obj 13 267 mtx 13 4;
#X text 113 174 zero the matrix in case the Teensy goes crazy (doesn't
really happen any more...);
#X connect 0 0 13 0;
#X connect 2 0 11 0;
#X connect 2 1 3 0;
#X connect 3 0 24 0;
#X connect 3 1 12 0;
#X connect 6 0 5 0;
#X connect 7 0 6 1;
#X connect 9 0 14 0;
#X connect 11 1 22 0;
#X connect 12 0 24 1;
#X connect 12 1 22 1;
#X connect 13 0 31 0;
#X connect 13 1 2 0;
#X connect 14 0 27 0;
#X connect 20 0 30 0;
#X connect 22 0 21 0;
#X connect 24 0 23 0;
#X connect 27 0 31 0;
#X connect 27 1 18 0;
#X connect 29 0 28 0;
#X connect 29 1 6 0;
#X connect 30 0 31 0;
#X connect 31 0 29 0;
#X restore 68 95 pd whole-matrix-and-data-diffusion;
#X obj 36 73 t a a;
#X obj 36 125 spigot;
#X obj 36 187 s to_mtx_mul;
#X obj 36 147 t a a;
#X obj 135 187 print;
#X obj 135 164 spigot;
#X obj 174 144 tgl 15 0 empty empty debug 17 7 0 10 -262144 -1 -1 0
1;
#X obj 349 300 s mtx_ramp;
#X obj 36 51 r matrix_msg;
#X connect 0 0 10 0;
#X connect 1 0 0 1;
#X connect 1 1 21 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 3 1 12 0;
#X connect 5 0 0 0;
#X connect 6 0 7 0;
#X connect 6 1 3 0;
#X connect 7 0 15 1;
#X connect 7 1 13 1;
#X connect 8 0 6 0;
#X connect 9 0 2 0;
#X connect 10 0 21 0;
#X connect 12 0 2 1;
#X connect 13 0 16 0;
#X connect 14 0 15 0;
#X connect 14 1 13 0;
#X connect 15 0 17 0;
#X connect 17 0 16 0;
#X connect 17 1 19 0;
#X connect 19 0 18 0;
#X connect 20 0 19 1;
#X connect 22 0 14 0;
#X restore 45 360 pd receive_and_collect_matrix_msg;
#N canvas 0 51 308 219 matrix_et_al 0;
#N canvas 500 230 547 412 create_matrix 0;
#X obj 37 17 inlet do_it;
#X obj 220 248 s pd-matrix;
#X msg 69 62 clear;
#X obj 37 181 t b l;
#X obj 37 39 t b b;
#N canvas 0 51 371 323 make_cathes 0;
#X obj 116 149 + 100;
#X msg 116 194 obj \$1 50 catch~ output\$2;
#X obj 116 171 pack;
#X obj 116 105 t f f;
#X obj 91 59 v inlets;
#X obj 91 37 inlet;
#X obj 116 216 outlet make_obj;
#X obj 91 242 outlet done;
#X obj 116 127 * 110;
#X obj 91 82 loop;
#X connect 0 0 2 0;
#X connect 1 0 6 0;
#X connect 2 0 1 0;
#X connect 3 0 8 0;
#X connect 3 1 2 1;
#X connect 4 0 9 0;
#X connect 5 0 4 0;
#X connect 8 0 0 0;
#X connect 9 0 7 0;
#X connect 9 1 3 0;
#X restore 37 231 pd make_cathes;
#N canvas 0 51 343 309 make_sends 0;
#X obj 86 162 + 100;
#X obj 86 184 pack;
#X obj 86 118 t f f;
#X obj 86 140 * 100;
#X msg 86 207 obj \$1 150 send~ input\$2;
#X obj 61 73 v outlets;
#X obj 61 50 inlet;
#X obj 86 229 outlet make_obj;
#X obj 61 253 outlet done;
#X obj 61 95 loop;
#X connect 0 0 1 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 2 1 1 1;
#X connect 3 0 0 0;
#X connect 4 0 7 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 9 0 8 0;
#X connect 9 1 2 0;
#X restore 37 256 pd make_sends;
#N canvas 0 51 315 289 make_receives 0;
#X msg 109 122 obj 10 50 r to_mtx_mul;
#X msg 86 146 obj 10 150 r mtx_ramp;
#X obj 63 97 t b b b;
#X obj 63 71 inlet;
#X obj 109 175 outlet make_obj;
#X obj 63 197 outlet done;
#X connect 0 0 4 0;
#X connect 1 0 4 0;
#X connect 2 0 5 0;
#X connect 2 1 1 0;
#X connect 2 2 0 0;
#X connect 3 0 2 0;
#X restore 37 282 pd make_receives;
#N canvas 672 51 504 576 make_connections 0;
#X text 185 124 connect to [mtx_*~];
#X text 185 290 connect from [mtx_*~];
#X obj 35 10 inlet;
#X obj 35 32 v inlets;
#X obj 60 100 + 1;
#X msg 60 289 connect 0 \$1 \$2 0;
#X obj 35 156 v outlets;
#X obj 92 245 +;
#X obj 107 223 + 1;
#X msg 60 123 connect \$1 0 0 \$1;
#X obj 60 200 t f f;
#X obj 60 267 pack;
#X obj 35 54 t f f;
#X obj 35 340 v inlets;
#X obj 53 387 v outlets;
#X obj 35 409 +;
#X obj 35 431 + 1;
#X obj 35 453 t f f;
#X obj 35 475 + 1;
#X msg 105 470 connect \$1 0 0 0;
#X msg 35 523 connect \$1 0 0 \$2;
#X obj 35 362 t f f;
#X obj 67 475 + 1;
#X obj 35 499 pack;
#X obj 35 317 t b b;
#X obj 303 445 outlet connections;
#X obj 35 78 loop;
#X obj 35 179 loop;
#X connect 2 0 3 0;
#X connect 3 0 12 0;
#X connect 4 0 9 0;
#X connect 5 0 25 0;
#X connect 6 0 27 0;
#X connect 7 0 11 1;
#X connect 8 0 7 1;
#X connect 9 0 25 0;
#X connect 10 0 11 0;
#X connect 10 1 7 0;
#X connect 11 0 5 0;
#X connect 12 0 26 0;
#X connect 12 1 8 0;
#X connect 13 0 21 0;
#X connect 14 0 15 1;
#X connect 15 0 16 0;
#X connect 16 0 17 0;
#X connect 17 0 18 0;
#X connect 17 1 19 0;
#X connect 18 0 23 0;
#X connect 19 0 25 0;
#X connect 20 0 25 0;
#X connect 21 0 15 0;
#X connect 21 1 22 0;
#X connect 22 0 23 1;
#X connect 23 0 20 0;
#X connect 24 0 13 0;
#X connect 24 1 14 0;
#X connect 26 0 6 0;
#X connect 26 1 4 0;
#X connect 27 0 24 0;
#X connect 27 1 10 0;
#X restore 37 307 pd make_connections;
#X obj 37 87 t b b;
#X obj 37 159 pack;
#X obj 69 109 v inlets;
#X obj 37 133 v outlets;
#X msg 220 198 obj 100 100 mtx_*~ \$1 \$2 15 ...........................................
;
#X connect 0 0 4 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 3 1 13 0;
#X connect 4 0 9 0;
#X connect 4 1 2 0;
#X connect 5 0 6 0;
#X connect 5 1 1 0;
#X connect 6 0 7 0;
#X connect 6 1 1 0;
#X connect 7 0 8 0;
#X connect 7 1 1 0;
#X connect 8 0 1 0;
#X connect 9 0 12 0;
#X connect 9 1 11 0;
#X connect 10 0 3 0;
#X connect 11 0 10 1;
#X connect 12 0 10 0;
#X connect 13 0 1 0;
#X restore 24 87 pd create_matrix;
#N canvas 0 241 1234 315 matrix 0;
#X obj 100 100 mtx_*~ 13 4 15 ...........................................
;
#X obj 100 50 catch~ output0;
#X obj 210 50 catch~ output1;
#X obj 320 50 catch~ output2;
#X obj 430 50 catch~ output3;
#X obj 100 150 send~ input0;
#X obj 200 150 send~ input1;
#X obj 300 150 send~ input2;
#X obj 400 150 send~ input3;
#X obj 500 150 send~ input4;
#X obj 600 150 send~ input5;
#X obj 700 150 send~ input6;
#X obj 800 150 send~ input7;
#X obj 900 150 send~ input8;
#X obj 1000 150 send~ input9;
#X obj 1100 150 send~ input10;
#X obj 1200 150 send~ input11;
#X obj 1300 150 send~ input12;
#X obj 10 50 r to_mtx_mul;
#X obj 10 150 r mtx_ramp;
#X connect 0 0 5 0;
#X connect 0 1 6 0;
#X connect 0 2 7 0;
#X connect 0 3 8 0;
#X connect 0 4 9 0;
#X connect 0 5 10 0;
#X connect 0 6 11 0;
#X connect 0 7 12 0;
#X connect 0 8 13 0;
#X connect 0 9 14 0;
#X connect 0 10 15 0;
#X connect 0 11 16 0;
#X connect 0 12 17 0;
#X connect 1 0 0 1;
#X connect 2 0 0 2;
#X connect 3 0 0 3;
#X connect 4 0 0 4;
#X connect 18 0 0 0;
#X connect 19 0 0 5;
#X restore 24 109 pd matrix;
#X msg 24 64 bang;
#X text 58 65 <- create new matrix;
#X connect 2 0 0 0;
#X restore 45 383 pd matrix_et_al;
#N canvas 600 65 500 335 module_abstractions 0;
#X text 41 18 Module abstraction arguments:;
#X text 40 35 1st: module number \, starting from 0;
#X text 40 52 2nd: number of inlets (output shift registers);
#X text 40 117 4th: number of outlets (input shift registers);
#X text 40 71 3rd: number of first inlet (output shift register) in
the matrix ([mtx_*~] outlet) \, starting from 0 (sum of args 2 and
3 of previous abstraction in the chain);
#X text 40 137 5th: number of first outlet (input shift registers)
in the matrix ([mtx_*~] inlet) \, starting from 0 (sum of args 4 and
5 of previous abstraction in the chain);
#N canvas 214 209 603 334 init-inlets-table 0;
#X obj 100 30 loadbang;
#X obj 100 52 delay 500;
#X obj 100 74 v num_of_modules;
#X msg 148 139 symbol \$1-get_inlet;
#X obj 125 163 s;
#X text 182 95 store all first inlets of modules (reason is explained
inside each modlues that uses this feature;
#X obj 125 117 t b f f;
#X obj 13 189 r give_inlet;
#X obj 13 211 tabwrite all_inlets_tab;
#X obj 100 96 loop;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 9 0;
#X connect 3 0 4 1;
#X connect 6 0 4 0;
#X connect 6 1 3 0;
#X connect 6 2 8 1;
#X connect 7 0 8 0;
#X connect 9 1 6 0;
#X restore 40 188 pd init-inlets-table;
#X obj 40 255 pow_sine~ 1 3 7 1 1;
#X obj 40 277 adc_dac~ 2 3 10 2 2;
#X obj 40 233 var_shapes~ 0 7 0 1 0;
#X restore 45 406 pd module_abstractions;
#X connect 2 0 13 0;
#X connect 7 0 13 0;
#X connect 8 0 13 0;
#X connect 9 0 13 0;
#X connect 10 0 11 0;
#X connect 11 0 14 0;
#X connect 14 0 13 0;
